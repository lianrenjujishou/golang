以下内容均是从golang官方提供的入门教程中总结的: https://tour.golang.org/welcome/1
Packages
1.每个Go程序都是由包(s)组成的
2.Go程序从main包(的main函数)开始运行
3.使用import关键字导入包
4.包名和导入路径的最后一个元素名称相同
*.从当前看，包就是一个文件夹，里面有好多文件，并且这些文件的第一个有效行都是"package 包名"
*.import关键字导入包名应该隐式的以Go安装路径下的src文件夹为默认搜索路径，这个是我猜的，但应该没问题，因为从导入的包名看"fmt", "math/rand", fmt是src下的文件夹， math是src下的文件夹，rand是math下的文件夹，所以说拿安装路径下的src文件夹作为基路径或说搜索路径应该没啥问题
Imports
1.在使用import关键字导入包时，可以使用多个import，每个import后跟一个包名，也可以使用一个import，将所有要导入的包都放在括号里。官方推荐使用第二种方法，官方叫它"因式分解法"
*.pa+pb+pc=p(a+b+c)

  import "fmt"
  import "math"

  import ("fmt";"math")
  import (
          "fmt"
          "math"
  )  //通过最后两个import判断"因式分解法"中多个包的分隔符为";"或"\n"
*.上面星号的最后一个import的写法是官方的写法，倒数第二个如果多个包写在一行要用分号隔开

Exported names
1.使用import将包导入进来以后，程序只能引用包中以大写字母开头的定义，可以理解为当执行import的时候会将相应包中以大写字母开头的定义给导进当前程序的空间，而那些以非大写字母开头的定义仅仅可以在包内部引用，官方将这些以大写字母开头的叫做"exported name",从字面意思上理解是"导出的名称",此时这个"导出"的动作应该是看作在执行"import 包名"的时候，会将包里以大写字母开头的定义从"包"里导出到程序的应用空间中。这么解释可能不太对，但目前这么解释的话是有帮助理解的。
2.一个包里可包含多个扩展名为go的文件，而在import的时候应该是将包里所有文件中的以大写字母开头的定义都导到程序空间中了。这个也是猜的，不过通过Packages那一节的例子中的math.Int //到这断了，应该是误删了，后面应该是 "这个例子可以推断出来"
Functions
1.函数可以带任意多个参数，包含0个
2.函数参数中，形参类型出现在形参的后面
3.函数基本语法func func_name(arg1 type1, arg2 type2) return_type { statements }  //这块要注意函数如果有形参,则形参的类型一定不能少,即func f(a)是错误的,要写成func f(a type).
Functions continued
1.当函数中连续的参数类型相同时，可以简写，只保存最后一个参数的类型
*. x int, y int   ->  x,y int
Multiple results
1.如果返回多个结果可以设置多个返回值的类型，多个类型使用圆括号括起来，位置在包含函数参数的圆括号后面
2.如果函数有多个返回值，则可以直接使用返回结果进行分解赋值
Named return value
1.函数返回值也可以被命名，就是函数定义中返回类型的位置，之前讲返回多个值的时候该位置是括号里放上返回类型，现在只是在返回类型前再加上变量名，作为返回的变量；如果要返回这种带有名称的返回值时，return语句后不接任何参数(这次看又发现了问题，return是不用加参数，但函数体中的变量名必须用函数声明时在返回值类型中所定义的变量，感觉这种情况只是在编译阶段编译器自动将返回值类型中定义的名称给加到函数中了，因为函数变量的赋值要不使用关键字var,要不使用海象赋值符:=,但给定的例子中直接使用的等号=进行赋值，就说明编译器在执行到x,y赋值之有就已经声明了，而这个声明应该是编译器阶段做的)。
2.需要注意的是这种形式最好只在较短的函数中用，如果函数较长的话用这种形式会损失程序可读性。
3.带名称的返回值在命名时最好是有意义的，即根据返回值名称即可知道返回的大概是什么东西
Variables
1.使用var来定义单个变量或是多个变量，变量的形式和函数参数中的形式差不多
*. var a int
   var a,b,c int
2.var关键字可以用在包级别，也可用在函数级别，说白了就是既可在函数里面使用var定义变量，也可在函数外面使用var定义变量。可能不准确但就目前看到的可以先这样讲
Variables with initializers
1.声明变量时可以包含初始化器，一个变量一个；所谓的初始化说中了就是变量赋值，这句话说白了就是声明变量时可以给变量赋值，一个变量一个值，这样更明了一些
*.var i, j int = 1, 2
2.如果声明变量时有初始化器，则变量后面的类型可以忽略，程序会将初始化器的类型作为变量的类型。换句话说就是声明变量时可以不指明变量类型，程序会将变量值的类型作为变量的类型
Short variable declarations
1.变量声明不仅可以通过var关键字，还可以使用:=符号，使用这种形式不需要var关键字，而且也不用显示的给出变量类型。但是:=和var有一点不同的是，var既可用在包级别又可用在函数级别，而:=只可用在函数级别
2.对照1来看，包级别的语句都需要以关键字打头
3.既然:=不需要显示给出变量类型，则肯定是用到推断功能了(infer)
Basic types
1.Go中的基本类型有:
布尔型: bool
字符串: string
整型: int int8 int16 int32 int64
无符号整型: uint uint8 uint16 uint32 uint64 uintptr          //int uint unitptr默认是自适应的,即虽然看起来int有好几种,unit也有好好种,但如果你是在32位系统上运行则,编译器会动将int精确为int32,也就是说我们用的时候只需要使用int和uint就行,不用人为的去写后面的位数; 但是如果你明确知道你想存储的是16位的,则你就用int16,这样即使你在32或64位系统上运行,用的也是int16,这样可以减少内存的占用. 至于uintptr还不会用,它的作用见:https://stackoverflow.com/questions/59042646/whats-the-difference-between-uint-and-uintptr-in-golang
字节型: byte  //unit8的别名
文字型: rune  //int32的别名，表示一个Unicode码点
符点型: float32 float64    //int 和float的最大值最小值在src/math/const.go中都有说明,也备注了算法,也可以直接使用math.MaxInt32等这样的形式直接输出
复合型: complex64 complex128   //complex64用来描述float32类型的实数和虚数,complex128用来描述float64类型的实数和虚数,详述:https://www.cloudhadoop.com/2018/12/golang-tutorials-complex-types-numbers.html
2.变量的声明也可以使用"因式分解"式，即使用一个var关键字完成多个变量的声明
3.int,uint和uintptr这三个类型在32位系统中它们的位宽是32位，在64位系统下它们的位宽是64位
4.对于整型一般就用int,除非定义时知道数值的大小int可能不够再去考虑其它整型(废话)  //这不是废话,上面在"无符号整型"后的备注中提到了,我们写的是int,但实际执行的时候,编译器是会根据程序所在系统的位数去相应的分配空间,而这句话存在的意义我能想到的一种情景是: 假设我们用的系统是32位的系统,如果直接使用int的话,编译器预处理替换为int32,但是我们想要存的数要比int32大,此时我们就可以显式的指定数值类型为int64,此时编译器在处理这块的时候,因为我们已经明明确说明了这是一个要用int64才能装下的数,就不会去考虑当前系统是32位的事儿了.
Zero values
1.当声明变量时，如果没有设置初始化器，则变量会默认赋一个该变量所属类型的零值:
  数值类型: 0
  布尔型: false
  字符串: ""
Type conversions
1.Go中的类型转换必须要精确指定要转换到的类型
，表现在实际的写法上即要将被转换值作为相应类型的参数
  var i int = 42
  var f float64 = float64(i)
  var u uint = uint(f)
  还可以使用:=形式:
    i := 42
    f := float64(i)
    u := uint(f)        //对于数值和字符串相转换,如var a int = 97 , var b string = string(a) 这种写法得到的b是ascii码,小写字母"a",而不是我们想要的"97", 想要得到"97"要使用strconv包的Itoa函数, var b string = strconv.Itoa(a), 得到b为"97" (https://yourbasic.org/golang/convert-int-to-string/)
2.C语言中的类型转换不强制要求加上被转换到的类型(C都忘了...)
Type inference
1.到目前为止变量声明的几种形式:
  var a int  //默认会为a赋值0
  var a int = 1  //带有初始化器的形式
  var a = 1   //有初始化器时变量类型可省，自动根据初始化器进行推断
  var a, b int  //同时声明多个类型相同的变量
  var a,b int = 1, 2  //同时声明多个类型相同的变量且带有初始化器的
  var a,b = 1, 2  //同时声明多个类型相同的变量，且带有初始化器，此时变量的类型可忽略，会自动初始化器进行判断
  a := 3  //:=这种赋值形式本来对类型就是隐式的需要根据值进行判断，并且不需要关键字var;但只能用于函数级别
2.如果之前定义了变量i, var i int,则将i作为一个新变量的值时，j := i , 新变量的类型和i的类型相同
3.如果使用:=声明的变量类型为数值型常量时，该变量的类型要看数值的精度，从而确定是int, float64, complex128还是...
Constants
1.常量声明使用关键字const
2.常量值可以是字符，字符串，布尔值或是数值
3.常量不能使用:=语法声明
4.这个是自己猜的，常量定义时就必须赋值，否则会出错，程序不会给默认值  //仔细想想这么做也是有道理的，常量代表固定值，或说后期不可改的值，即然这样，你声明常量时如果不初始化，让编译器给个zero value就没啥意义了，所以干脆就设计成常量声量时必须有值，没值编译不过.
Numeric Constants
1.常量声明也可使用因式分解法"factored"
2.一个未明确写明类型的常量具体的类型要根据右边的值来确定
3.位运算符: & | ^ << >>   &:都有1才是1; |:有一个是1就是1; ^:有且只有一边是1才是1; <<:左边划掉几位右添添几个0; >>:右边划掉几位左边添几个0  //该教程中举的例子很好:https://www.tutorialspoint.com/go/go_bitwise_operators.htm
For
1.Go中只有一种循环结构，for循环
2.for循环的基本结构为for关键字，然后是由两个分号分隔的三部分，接着是由一对花括号将要执行的语句括起来。需要注意的是由分号分隔的那三部分不需要使用圆括号括起来
3.init部分的变量声明仅在该for循环中有效
*.这个for的每一部分就不具体说了，基本上和其它语言的for循环没区别
For continued
1.这个是接上一节的For讲的，主要说的是由分号分隔的那三部分中的第一部分init和第三部分post都是可选的，即如果不写也是正确的。其实如果省略第一和第三部分，则一般情况下，第一部分会从包级别中去获取，第三部分会在for循环语句中获取，总的来说还是完整的，只是位置不一样罢了
2.虽然省略了第一和第三部分，但是那两个分号还是结构中必须有的
*.抓住for循环的本质，有初始点，有判断条件，有结束点
For is Go's "while"
1.上面一节还说了如果省略了初始化部分和post部分但两个分号还是必须有的，这节就打脸了，即使省略了第一三部分，两个分号也可省略，这样写下来看起来就像其它语言中的while循环了，但还是那句话，虽说省略，但那三个基本点肯定在上下文都 是可以找到的
  *. func main() {
         sum := 1  //这部分相当于init
         for sum < 1000 {
             sum += sum  //这部分充当了post
         }
     }
Forever
1.这节还是继续对for结构由分号分隔的三部分做说明，这次是条件部分也可省略，如果这部分省略，如果在执行语句中没有设定退出条件，则会永远的执行下去，话又说回来了，如果在执行语句中设定退出条件，这不是又是换汤不换药嘛，只不过相应的元素没有位于由分号分隔的位置；抓本质！
  func main() {
    sum := 1
    for{
      if sum < 1000{
        fmt.Println(sum)
        sum ++
      } else {
        break
      }
    }
  }     //上面的语句中随然for循环部分啥都没有,但其实三要素都在,initializer为sum:=1,条件部分为if{}else{},第三部分为sum++; 其实大家都在
If
1.Go中最基本的if语句也是if引导，后面跟条件表达式，注意这块和for相似，条件部分不需要使用圆括号括起(对于for是由两个分号隔开的三部分不需要使用圆括号括起，但是无论是if还是for那个位置都是一样的，都是位于关键字后，起始花括号前)；然后后面就是跟着由一对花括号括括起来的执行语句
If with a short statement
1.这节讲的if的特性目前接触的其它语言里没有，或是没有见过，就是在if的条件表达式前加一个语句，类似于for中的init部分，仅仅在最开始时执行一次
2.if中的init部分和条件表达式部分也是使用分号隔开
3.if语句中的init部分声明的变量的作用范围为它所在的if语句，生命周期为if语句执行结束
*. if v := math.Pow(x, n); v < lim {
      return v
   }
If and else
1.if语句中最最常用的还有一个else关键字,这节主要讲的是if结构中init如果定义了变量，则不仅在if的语句块中有效，在相应的else语句块中也有效
*.if v := math.Pow(x,n); v < lim {
    return v
  } else {
      fmt.Printf("%g >= %g\n", v, lim)
    }
Exercise: Loops and Functions
1.这个练习本节最后再做，先将基础概念整完
Switch
1.Switch语句其实是if...else...的更短的一种书写形式，但if...else...过多的时候使用switch语句可读性会好一些; switch同if一样,也可以有initializer部分,同条件部分用分号隔开,当然也可以省略initializer部分,具体用不用根据实际情况去定; 使用switch时,当所有条件都不满足时,执行的是default关键字下的语句,这点要注意.
2.在像C等一些语言中也有swtich语句，在这些语句中，每个case下的执行语句都要有一个break来跳过继续对下面case检测执行。但在Go中不需要在每条case下的执行语句中都加上break语句，实际上是Go已经为我们考虑好了，那个break是程序执行时自动加上去的，不用我们干预，本质上来说还是有的
3.Go中case后面的类型不限于常量，且相应的值也不一定要是整数
*.switch主要用于替代较长的if...else...
Switch evaluation order
1.这节主要讲的是如果switch要有多个case时，这些case的评估顺序是啥样的，这个其实都知道，是从上向下的，并且一旦遇到哪个case后面的值匹配成功了，则执行完相应case下面的语句后就不再继续向下匹配其它的case后面的值了，因为之前也说过,Go自动为每个case下面的执行语句的最后面加了break来跳出switch
Switch with no condition
1.当switch中无条件表达式时，条件表达式相当于true
2.其实又回到要理解问题的本质上来了，其实所谓的无所件，只是条件部分不在switch的条件表达式部分了，而是转移到每个case值上，万变不离其宗
*.当switch无条件时，主要是处理较长的if...then...else...
*.switch {
        case t.Hour() < 12:
          fmt.Println("Good morning!")
        case t.Hour() < 17:
          fmt.Println("Good afternoon!")
        default:
          fmt.Println("Good evening.")
   }
Defer
1.函数前面如果加上defer关键字的话，如果该函数在另外一个函数里面时，在执行到带有defer前缀的函数时，仅仅会将该函数进行预处理，即将变量换成值这类的操作，但并不会立刻执行，直到这个函数的外层函数执行完毕后，才会执行该函数
Stacking defers
1.如果函数中存在多个defer时，则这多个带有defer的函数会被入栈，栈的原理是后进先出，所以在相应的外层函数执行完后，里面带有derer的函数是被从后向前执行的
Pointers
1.Go语言也支持指针，经常在C和C++上听说指针
2.Go中的指针比较简单只有一种声明形式，不支持运算
  *T:  var p *int  //声明一个指针p,p中存的是地址，该地址指向的内存区域存的是int型值(我猜这个int指的是变量值的类型，而不是变量分配的内存地址的类型,话说内存地址有类型吗?查了一下好像是有,是无符号整型,说白了它就是用来告诉我们你这个数据存储在内存中的起始位置)
3.给指针变量赋值的一般形式是: 地址符&加上变量名
  i := 42  p = &i
4.指针变量前加上*表示的是该指针变量指向内存区域的值
  *p = 21  //指针变量存放的实际是内存地址,就该例来说p存放的实际上是在内存中为变量i分配的地址；而加上*之后，*p表示的是指针变量p的值(变量i的内存地址)指向的值)
  *.指针其实很简单，只是比普通的变量多一层而已，我觉得越说多越乱，先这样吧
Structs
1.tutorial中讲的是struct(结构体)是一个字段的集合，这个可以理解，在C中看过对struct类型的描述，C中其实也是一堆字段的集合，而且这些字段的类型可以是任意的,就目前可以简单的理解成struct体中是一堆没有initializer的变量声明(可能不准确，但目前看是这样子的)
Struct Fields
1.对struct中的field(字段，成员)的访问，是通过点符号(".")实现的
  type Vertex struct {
       X int
       Y int
  }
  func main() {
    v := Vertex{1, 2}
    v.X = 4
    fmt.Println(v.X)
  }
*.不同语言中对于同一概念的翻译可能不同，主要的还是明白本质意思
Pointers to structs
1.还可以通过struct pointer(结构体指针)来访问struct fields(结构体的字段或叫成员)
2.当p的类型为struct pointer时，正常情况下应该使用(*p).X才能够访问结构体中的field X,但是Go语言允许我们在不明确表示废弃*前缀的情况下直接使用p.X的方式来访问结构体中的X field(好多初学者其实对于一些概念的描述可能会很迷糊，因为以前没接触过，脑子里没有可供参考的东西，我当时也是，现在再回头看，就要简单的多；比如这点开头说的p的类型为结构体指针，其实要明白，其实说的就是p中存放的值指向的内存地址处存放的数据其类型为结构体，而给结构体指针p前加上*号前缀就表示该结构体内容本身了.举例来说,有10个抽屉,相当于内存中的地址,我将一把锁放在了第3个抽屉,那么 假设声明了var p *锁,则p的值就是3, *p就是那把锁)
3.struct value加上&符号，返回的是一个指向struct value的指针(这句话听起来也别扭，首先struct value是个什么东西？(从例子上看其实就是类似于类的实例，这么说不准确，准确来说应该就是类的实例，因为结构体也是一种类型，所谓类型就是类，所以说struct value其实就是类的实例)也不好描述，看例子吧: p=&Vertex{1,2} 这个例子中，Vertex{1,2}相当于描述中讲的struct value; 此时p是一个指针变量，也就是说p中存放的是Vertex{1,2}这个实例在内存中被分配的地址，然后上一节也说了按理说如果要引用Vertex中的值的话，需要用(*p).X/Y,但是Go语言在这块为我们做了处理，即p的*前缀可以省略掉)
Struct Literals
1.struct literal主要的意思是:通过给出结构体中字段的值来表示最近分配的结构体值(struct value,上面Pointers to structs第3点也误差了,struct value其实就是对结构体类型的实例化)。看完例子看感觉,所谓的Struct Literals是指通过给结构体类型中字段赋值的方式来得到stucture value,也就是说可以将Structure Literal理解为一种得到structrue value的手段.而学到的新东西是在实例化化的时候，结构体中的所有字段不必完全都赋到值，可以只赋一部分，剩余那部分没赋到的，会根据之前讲过的，按相应类型的"零值"去赋(整型的是0,字符串类型的是""等等吧,这个也有一部分是自己猜的，不过应该没啥大问题),下面是官文中给的例子:
    type Vertex struct { X, Y int }
    var (
    	v1 = Vertex{1, 2}  // has type Vertex
    	v2 = Vertex{X: 1}  // Y:0 is implicit
    	v3 = Vertex{}      // X:0 and Y:0
    	p  = &Vertex{1, 2} // has type *Vertex
    )
2.我感觉把Struct Literal叫做结构体的实例化方法或叫创建结构体的对象的方法比较合适(根据给出的例子推想出来的)
Arrays
1.数组类型的声明: [n]T   //一个含有n个类型为T的数组(声明一个数组，该数组有n个类型为T的元素)
  var a [2]string  //定义一个含有2个类型为string的数组a(声明一个数组a,该数组中有2个类型为string的元素)
2.数组的引用和赋值与其它语言一样，都是使用角标的形式
  a[0] = "Hello"
  a[1] = "World"
3.声明数组时如果限定了长度，则以后使用该数组时，长度就是固定的了，不可以对数组的长度进行重定义;但最后一句话不是很明白:This seems limiting, but don't worry; Go provides a convenient way of working with arrays.它说的意思是明白，前面说了声明时带有长度的数组后期不可改变大小，但又说这种限制不用担心，Go为我们提供了一种方便的方式来使用数组，这句话指的是什么?指的是后面要说到了声明时可以不定义长度的形式吗?
4.声明数组时赋值(或者叫声明一个带有初始化器的数组?) [n]T{value1, value2, ...}
  var primes := [6]int{2, 3, 5, 7, 11, 13}  //这里看出错误了，因为这里的声明用的是短形式:=,所以说打头的关键字var是没有必要的，看了一眼原文也是这样，先不去var,暂且留在这里吧
5.总结一下数组的声明赋值常用方法:
  a := [2]int{1,2} //短形式的海象符必须在声明时就赋值
  var a [2]int   a[0]=1  a[1]=2  //使用var可以先声明,后面使用索引的方式赋值
  var a [2]int = [2]int{1,2}  //使用var同样可以连声明和赋值在一块做了
  var a = [2]int{1,2} //使用var可以省略左边声明部分的显式类型说明,因为可以根据右边推断出来
Slices
1.首先说了array的大小是固定的。接着引出相对而言slice是变化的，slice在其它语言中经常翻译为分片，通过看他的描述，在Go里对slice翻译为分片也是合适的。而分片其实指的是取array的一部分，也就是说slice一般是和array联用;
2.slice也有类型，为[]T,即未指定大小，[]中未指定分片的大小，也就是说大小是动态的，T一般为相应array的类型;
3.分片通常的用法是先声明一个数组，然后通过指定数组的上限和下限来为slice赋值
  *. primes := [6]int{2, 3, 5, 7, 11, 13}
     var s []int = primes[1:4]   //这里面的[]int是可以省略的，也可写作:
     s := primes[1:4]
4.接着3说，数组的分片一般是包前不包后的，即a[1,4]是指数组a中第1到第3个元素
*.第三条的例子，可以看出分片s的类型是[]T,这个现在就死记吧，数组的分片(感觉叫切片更生动一些)(不知道将slice和array连起来说准不准确，暂且先这样记吧)，一开始我以为[]T只是因为方便不用刻意的去关心分片的大小，事实上Go可能也是这样考虑的；我尝试着将分片s的类型换成[3]int,因为后面的分片就三个元素嘛，但是执行失败了。而且回显明确告诉我分片的类型是[]T(不能指定slice包含元素的数量)
Slices are like references to arrays
1.slice不存储任何数据，对slice中任意元素的更改其实是直接改变该slice相应的underlying array.举例来说 underlying array为base=[1,2,3,4,5,6,7,8,9,10]这10个数，然后我对该underlying array做了一个切片，比如slice=base[0:5],我们都知道变量声明完之后其实是在内存中分配了一片空间，然后使用变量时，其实是利用变量的地址准确的找到变量数据在内存中的位置(大概是这样，具体的也记不清了)，再说这里的分片，其实也是内存中的一段地址，特殊的是这个地址是在underlying array的范围内取，这样一来，其实对分片数据的更改，就直接作用到underlying array中的数据。一开始我想用array的别名来描述slice,但是这样不准确，因为别名是对underlying array的完全引用而slice可以是整个基础数组也可能是基础数组的一部分,所以不能把slice理解成其underlying array的别名(这段的描述有点屎了)
2.既然slice会直接改变它underlying array中的数据，则其它的slice肯定也会受到影响
Slice literals
1.前面有个struct literal从例子中看，struct literal就是一个创建结构体实例或是对象的方法或叫手段,即通过给结构体中字段进行赋值的方法来得到struture value(也就是所谓的结构体实例或对象)
2.对slice literal官方tour给的描述是:"a slice就像是一个没有长度的array literal"，
其实不是很理解，暂且将slice literal的结构定义为 "[]T{v1,v2,...,vn}"
3.声明一个array literal: [3]bool{true, true, false}
4.声明一个slice literal: []bool{true, true, false}
*.其中3和4的区别是，3只是简单的声明一个含有三个为bool类型的array并赋值；而4其实可以理解为2步，第一步是创建一个array第二步是基于第一步的array创建一个slice
5.对于结构体在声明时初始化的时候，需要注意的是，因为结构体中不止一个field，而这些所有的field对于struct来说是一个整体，所以在声明时给结构体的赋值时每个元素都是一个由花括号括起来的，含有所有field的整体
  s := []struct {
    i int
    b bool
  }{
    {2, true}
    {3, false}
    {5, true}
    {7, true}
    {11, false}
    {13, true}
  }
6.总结一下：所谓的slice literal就是数组的声明与分片的声明合成一个了(先这样理解吧) //或者参照structure literal,slice literal就是使用[]T{x,...}的方式得到slice的一种方法
7.再多说一句，从之前的struct literal,到array literal, 再到slice literal,其实头两个基本上就是之前讲的变量声明的时候就顺带赋值了，而slice literal虽说也是声明的时候就赋值了，但是不要忘了，slice是要基于array的，这句话是关键。所以再理解slice literal的时候就要分两步理解，第一步是array的创建，第二步是slice的build(叫构建，生成啥的，随便叫吧)
8.slice也是有类型的，它的类型是"没有长度的数组类型" []T
9.再说一下slice literal的定义：slice literal就像是一个没有长度的array literal
Slice defaults
1.如果slice的low bound和或high bound省略的话，则默认会用它们的默认值替代，即，如果low bound省略则用0替代;如果high bound省略的话，则用len(array)替代
    var a [10]int
    a[0:10]
    a[:10]  //low bound default to 0
    a[0:]  // high bound default to 10
    a[:]  //low bound default to 0 and high 10
2.看这节例子结果的时候我其实一开始有点理解跑偏了，我把所有的操作都和数组联系起来，其实不是的:
s := []int{2, 3, 5, 7, 11, 13}  //这个s是对右侧无名数组的一个分片
s = s[1:4]  //这个是从上面那句得到的s中取第1，2，3个元素(3,5,7)
s = s[:2]   //这个是在上面那句s的结果取第0和第1个值(3，5)
s = s[1:]   //这个是在上面那句的s的结果取第1个值(5)
*.上面几节也说过slice其实是对array的引用，我理解slice其实存的是地址，而不是值，对slice[1]的修改，其实是对在slice[1]中存储的地址所指向的数据进行修改，所以才会有之前说的对一个slice的修改，可能会影响到其它的slice,如果它们有相同引用的话
*.上面那4个s,第2，3，4分别是以上一句为源进行截取，但是下一节会讲到，它们是可扩展的，如果扩展的话，2，3，4中每一个的high bound最大都可以到6,len({2,3,5,7,11,13})，因为它们本质上还是在那个无名数组的范围内操作
Slice length and capacity
1.每个slice都有两个属性，一个叫length,一个叫capacity.
  length的值为当前slice中含有的元素的个数
  capacity的值为当前slice所基于的那个array的长度减去当前slice的low bound
2.可以通过len(s)来得到分片s的length属性值
  可以通过cap(s)来得到分片s的cap(s)属性值   //看到这明白了goroutines 有一节的代码中的cap()函数是啥意思了
  *.len(s)理解为当前slice的长度; cap(s)理解为当前slice可能的最大长度
  *.len()函数没啥说的，好理解; 而cap()函数我觉得应该理解为:"左值不动, 只能右值向右扩展"，此时再去理解cap()的值是len(array)-slice(low bound)就通了
3.capacity其实可以理解为当前分片最多可以拥有的元素个数，这个个数不要和当前分片的长度相混淆，当前分片的长度指的是当前分片已有元素的个数，而当前分片最多可以拥有元素的个数倾向于分片的扩展性，而这个扩展性也是基于那个最基础的array,因为对于一个分片来说，你再怎么折腾也是在你所基于的那个array所拥有的范围内活动。所以正常情况下可以理解为capacity的值就是其所基于的那个array中元素的个数，但这样说还不对，因为概念中明确强调了，是从low bound这个数值开始，所以capacity的最大值其实是len(array)-low bound
4.可以随时扩展分片的high bound,但是不能超过len(array),否则会报"slice bounds out of range"的错误
*.再次强调，分片中存放的应该是基础array中元素的地址，所以分片的活动范围最大就是array所表达的那个范围
*.这一节看的其实还是有点小纠结的，因为涉及到了对分片进行分片，其实只要抓住本质一切都很明朗
*.这一块要多看，多理解理解
Nil slices
1.之前讲过如果变量声明的时候如果没有初始化器，也就是说如果声明时不赋值，则Go会按类型给相应的变量赋一个值，这个值Go叫它zero value,也就是零值。不管叫啥明白这个意思就好。同样的slice如果声明时不赋值也会默认有一个zero value,为nil.
2.从例子来看，所谓slice声明时不赋值，指的是没有右边的数组那部分，var s []int,这样的slice,它的len()和cap()都是0，因为这个slice没有underlying array(这个词我还是觉得翻译为基础数组好一些)
3.一般是用if语句去判断slice是否为未初始化.这块就要注意了, "var a []int" 和 "var a = []int{}" 是不一样的,前者是没有初始化,此时a值为nil,而后者的值不是nil, 另外通过实践还从编译器得到一名话,"slice can only be compared to nil",即在使用if语句判断的时候,条件部分的"=="号一边是slice名称,另一边只能是nil.//得到提示使用的例子为:var x []int = []int{} if x==[]int{}{ fmt.Println("nil!")}
Creating a slice with make
1.首先Go提供了一个内建的函数,make,它的返回值就是一个slice；文中还有一句"this is how you create dynamically-sized arrays"也就是make是用来创建动态数组的方式，记得其它语言中当数据的类型为[]T时声明的就是动态数组，但是在Go中，[]T只是slice的类型，数组array的类型必须是[n]T即必须指定大小。还接着上面那句英文，感觉给的例子不是创建的动态数组呀，"a := make([]int, 5)"还是指定了数组的大小了，哎，这块有点不明所以。 //现在感觉呀,golang中所谓的动态数组和C中的还不太一样, golang中的动态数组的动态是有一个大前提的,即在underlying array下的动态, 这么想应该就通了
2.内建函数make的参数可以是两个，也可以是三个，但是第一个一般都是slice的类型:
   两个参数 make([]T, slice_len)
   三个参数 make([]T, slice_len, slice_caps)
   *.两个参数的make逻辑: 先根据[]T中的T和slice_len生成一个无名的数组，并且给该数组赋slice_len个0,此时数组生成了，再根据[]T来生成slice并返回(感觉如果没有caps参数的话，默认caps的值等于len的值)
   *.三个参数的make逻辑: 先根据slice_caps确定无名数组的长度，然后根据[]T和slice_len创建slice并确定slice的元素个数(说白了就是slice中有几个0)
   *.上面这两条完全是猜测，待后期接触了关于make的api说明再好好理解一翻
   *.刚又悟出了两点: 
         1.两个参数时，省略的第三个参数值和第二个值相同；且第三个参数值表示的是underylying array的长度，第二个参数表示的是slice的长度;
         2.三个参数可以参照两个参数，第三个参数为underylying array的长度，第二个参数为slice的长度
3.到现在是看出来了，分片的可伸缩性，只要是在underlying array所表达的范围内可以随便折腾; 还有一点需要注意,make函数中,第三个参数slice_caps一定是大于等于第二个参数slice_len的.
4.再通过例子来了解一下make两个参数和三个参数:
    a = make([]int, 6)  此时虽说是两个参数,但是预处理的时候第三个参数同第3个,即,在执行前原表达式会被改为: a = make([]int,6,6),然后先根据第三个参数创建一个无名数组,这个无名数组有6个0,然后根据第一,二个参数,确定slice的大小 a := [8个0][0:6].此时根据上面的算法,len(a)值为6,cap(a)的值为8-0=8.
    a = make([]int,6,8),有了上面2个参数的,3个参数的也就不用说了
Slices of slices
1.叫slices of slices，其实就像c或java中的多维数组，使用方法一模一样，都是通过多维索引，看第一眼的时候觉得会难一些，其实不然。
  board := [][]string{
      []string{"-", "-", "-"}
      []string{"-", "-", "-"}
      []string{"-", "-", "-"}
  }
2.strings包里的Join()函数可以将slice或是array中的字符串进行拼接并输出
Appending to a slice
1.这个很好理解，和python的列表追加函数是一个意思，但是用法不一样；
2.append函数的定义: func append(s []T, vs...T) []T
3.append函数的实际用法: s = append(s,1)  //其中s是slice;可同时追加多个值
4.当追加的元素个数超过了slice当前可以包含的最大个数cap(slice)时，Go会给slice重新分配一个array,并且将返回的slice指向这个新的underlying array(这个应该就是原先那块地不够存了，然后根据返回的slice的长度重新找一块地存储它，并且将slice指向新的array,也就是说如果返回后的slice的长度如果超过了当的undelying array的长度后，slice append之前的&slice[0]和slice append之后的&slice[0]已经不是一个值了):
    func main() {
    	age := [3]int{1,2,3}
    	fmt.Println(&age[0]) //原始数组第一个元素的地址
    
    	sli := age[0:1]  //原始sli,里面只有一个元素len(sli)=1,cap(sli)=3
    	fmt.Println(&sli[0]) //因为sli的len,还未超过基础数组的大小,所以输出值同上
    
    	sli = append(sli,4) //向sli追加1个元素,此时len(sli)=2,cap(sli)=3
    	fmt.Println(&sli[0])//因为sli的len,还未超过基础数组的大小,所以输出值同上
    
    	sli = append(sli,4) //向sli追加1个元素,此时len(sli)=3,cap(sli)=3
    	fmt.Println(&sli[0])//因为sli的len,还未超过基础数组的大小,所以输出值同上
    
    	sli = append(sli,4) //向sli追加1个元素,此时len(sli)=4,cap(sli)这个大小目前还不知道,因为不清楚,重新分配后的基础数组在原数组的大小上做加法运算的规则
    	fmt.Println(&sli[0]) //此时因为len(sli)已超过了3,所以重新分配了基础数组的位置,而sli又是对基础数组地址的引用,因此此处的第0个元素和上面不同了
    	fmt.Println(&age[0])
    	fmt.Println(age)
    	fmt.Println(sli)
    }
Range
1.for循环中的range形式用于遍历一个slice或是一个map
2.当使用range遍历一个slice的时候，每次遍历会返回两个值，index和与之对应的value(文中特别强调那个值是slice相应位置的一个copy,说白了就是告诉我们，对slice的遍历并不会影响原slice的内容，即并不是说将0位置的索引值返回后，这个值就从原slice删除了)
3.for循环中对slice使用range的形式: for i, v := range slice { statements}  //需要注意的是在for和range联用时,不能将i,v:=range slice看成是上面讲for循环三个部分的第一部分,而是这样就够了,如果你强行加上iv:range slice;condition;x++|x--是会报错的,具体后面还要看一下for和range联用的语法中有没有写其它的.
*.for循环中对map的遍历还没说，因为还没看到map,后面应该有相关的例子,到时再补
Range continued
1.刚才说过for循环中的range slice形式，会返回两个值，一个是index,还有一个是和index相对应的值;如果我们只想要index,则可以将value的位置替换为_,反之，如果只想要value,则可以使用_代替index:
  for i, _ := range slice
  for _, value := range slice
2.如果只想要index值，可以直接将",value"直接省略,即:
  for i := range slice
Exercise: Slices
1.练习部分，下一遍再看吧
Maps
1.map是由多个键值对组成，这个和其它语言中的字典，哈希啥的没区别
2.map使用的时候有以下几种情况:
 a.声明但未初始化的map,其值为nil,最关键的是未初始化的map不能被赋值:
    m := map[string]int
    m["age"] = 18     //上面这两句是不正确的写法,因为上句m声明时未被赋值,m的值为nil,此时不能直接给m赋值
   当m值为nil的时候,通常的用法和slice是一样的,即放在if语句中判断其值为nil:
    if m == nil { fmt.Println("nil!")}
 b.声明但未初始化的map,如果也想被赋值,其中一种方法是使用make方法返回一个同样类型的map对象:
    m := map[string]int
    m = make(map[string]int)
    m["age"] = 16   //经过上句make函数这么一折腾,此时的写法就是正确的,我经常忽略的一点就是第一句声明的时候m后的符号是海象符":=",第二句赋值时m后的是等号"=".
 c.可以直接使用make函数返回一个可被赋值的map对象
    m := make(map[string]int)
    m["age"] = 16  //此时的写法是正确的,因为make函数的参数为map类型时,返回的就是一个可直接操作的map.
 d.声明的时候直接将map进行初始化则后面可以直接给这个map赋值:
   *.声明的时候直接初始化,应该说的就是后面所说的map literal, 它是得到可操作map对象的一种手段.
    m := map[string]int{"zhangsan":19}
    m["liSi"] = 20  //这种写法是正确的,因为上句m在声明时赋了值,m的值不再是nil,故后面可以直接向m赋值
 e.还需要注意的就是当map的数据类型是稍复杂一点,如结构体的时候,初始化和后面赋值时的写法:
  type Vertex struct { Lat, Long float64 }
  初始化:
    var m = map[string]Vertex{
       "zhangsan":Vertex{80.6,-90.9},
       "lisi":Vertex{90.6,-80.9},
    }
  未初始化但使用make函数得到了可操作的map对象:
    var m map[string]Vertex
    m = make(map[string]Vertex)
    m["Bell Labs"] = Vertex{ 40.68433， -74.39967, }   //重要关注的是这句,即Vertex作为值时的写法
  同样,复杂的结构也可作为map中的键:
    type Vertex struct { X,Y int }
    var m  map[Vertex]int
    m = make(map[Vertex]int)   //上两句也可写为一句 m := make(map[Vertex]int) 或写为 m:= map[Vertx]int{Vertex{2,3}:4}
    m[Vertex{1,2}] = 3
    fmt.Println(m[Vertex{1,2}])  
Map literals
1.map literals指的同上边一样,即在声明时赋值从而得到相应的map对象.之前说的是上面讲的struct literals不同于其它的literals,当时的想法是看代码中先有type Vertex struct {X,Y int},然后下面才是var x := Vertex{1,2}就觉得struct literals和其它类型的literals不同了, 但其实是我想错了, 重要的一点是,所谓T literals的前提是你得先有T才行啊,你有了T下面才能谈T的literals,而之前的错误想法来源于,像slice,array这些都是内置的类型,可以直接用,而Vertex是我们自定义的一个类型.
2.这一节的map literal看例子也是在声明时一并赋值，看一下例子中的部分代码:
  type Vertex struct {
    Lat, Long float64
  }
  
  var m = map[string]Vertex{
    "Bell Labs": Vertex{
      40.68433， -74.39967，
    },
    "Google": Vertex{
      37.42202, -122.08408,
    },
  }
Map literals continued
1.下面的例子是官文给的,map实例化的时候top-level type可省时的代码:
  type Vertex struct {
    Lat, Long float64
  }
  
  var m = map[string]Vertex{
    "Bell Labs": Vertex可写可不写{40.68433, -744.39967},   // "Bell Labs":[Vertex]{40.68433,-744.39967}本来想写这种形式,用[]表示是可选的,但[]在编程语言里又比较敏感怕引起混淆,所以干脆就用大白话表示了
    "Google": Vertex可写可不写{37.42202, -122.08408},
  }
*.这里其实主要就是搞不清楚top-level type是个啥玩意儿,一开始认为是在函数外声明的类型就是top-level type,因为go中没有类的概念,所以也谈不到在某个类内部声明.但是通过测试无论是在main函数里面还是外面声明Vertex,m在实例化的时候,相应键值中Vertex关键字都能省.所以之前想的肯定不对,结果上网上搜了搜,有个人还专门为弄不懂这个东西去开了个issue,后面他也是在stackoverflow上提问得到了相对满意的答案(另外该链接还给出了另一个字典值可省略类型名的情况,即在声明字典类型时,map[int]struct{x,y string},这样直接将类型声明嵌到另一个类型声明中,因为该struct结构体没名,故实例化的时候键值处直接{}即可),这个答案链接为: https://stackoverflow.com/questions/47579004/what-can-be-used-in-a-map-literal-instead-of-a-type-name-in-go  大概意思是:
基本上讲的是当定义了一个接口I时,如果后面类型A实现了I(中的方法),类型B也实现了I(中的方法),则当给一个为[int]I的字典实例化的时候,就要明确的在键值处写为A{},还是B{},因为如果就一个A类实现了接口I(中的方法),则你在实例化的时候写作3:{},则go编译器会根据你声明的定型直接将{}处理为A{},但现在有两个类都实现了接口I,此时就得你显式的给出来这个类型了:
    type I interface {ok() string}
    
    type A struct{}
    type B struct{}
    
    func (a A) ok() string {
    	return  "a"
    }
    
    func (b B) ok() string {
    	return  "b"
    }
    
    func main() {
    m := map[int]I{
    	3: A{},
    	4: B{},  //注意这样写的话末尾的逗号要有,否则会报错
    }
    
    fmt.Println(m[3].ok())
    fmt.Println(m[4].ok())
    }

但是按照stackoverflow上的逻辑来看, 如果我只定义了一个实现了I的类型,则m中实例化的时候,键值部分就能写{}而不用前缀个A或B了,但实际情况不是这样的:
    type I interface {ok() string}
    
    type A struct{}
    //type B struct{}
    
    func (a A) ok() string {
    	return  "a"
    }
    
    //func (b B) ok() string {
    //	return  "b"
    //}
    
    func main() {
    m := map[int]I{
    	3: {},
    //	4: B{},  //注意这样写的话末尾的逗号要有,否则会报错
    }
    
    fmt.Println(m[3].ok())
    }
上面的代码是报错的,说"missing type in composite literal",而将 3:{} 改为3:A{}后,执行就正常了.
通过上面这两段代码我觉得stackoverflow中说的和主题不符.我现在又有了新的理解,也是通过stackoverflow上的这个例子和官文中定义的Vertex结构体类型共同找到的灵感,即因为I是一个接口,可以被很多类型实现,所以在给它传值时,就一定要明确指定哪个实现了I的类,即使当前只有一个类实现了I中的方法.但像之前定义的Vertex类,因为go中没有继承的概念,所以一说到Vertex就只有一个,唯一的一个,它没有子类啥的,因此即使没有明确在{}前给出类型名,golang编译器也能推断出来.这可能就是所谓的top-level type吧,当然这是猜的.而在给字典赋值时又出现了问题:

func main() {
	type Person struct {
		Age int
	}
	var d map[string]Person = map[string]Person{
		"zhangsan":{18},
		"lisi":{19},
	}
	delete(d,"zhangsan")
	fmt.Println(d)
	d["zhangsan"] = Person{20}  //这句
	fmt.Println(d)
}
上面代码备注那句在给"zhangsan"赋值时,后面一定要写成Person{20},而不能写成{20}, 对于这个例子我的理解是,在给字典d初始化赋值时,会考虑到字典的键或值的实际类型,然后看这些类型是否为top-level type(按照上面最后一句我自己的理解走),去判断赋值时这个类型关键字是否可省. 而一旦初始化完成了,后面使用得到的对象进行赋值时,就不会考虑那么多了,就直接是拿你写的类型值去和d定义中的比较,正确则执行,不正确则报错,即使用初始化后的对象对字典进行更改时,就没有了推断的过程,只有比较的过程,因此此时的Person必须要写.

Mutating Maps
1.强调一点，变量要先声明后使用，或者在使用的时候直接声明，就第二点来说，比如elem和ok之前都没有声明，则可以在使用的时候使用短声明的方式直接声明: elem, ok := m[key]
2.这节主要讲的是map是可变的嘛，所以下面几点主要围绕着可变来说:
  a.改变某个键的值  m[key] = new value
  b.检索某个键的值  elem = m[key]  //前提是elem在前面已经声明，如果前面没有声明elem,则可以使用短声明的格式在赋值时声明:  elem := m[key]
  c.删除键值对,其实只要删除key就相当于将整个键值对都删了: delete(m, key)
  d.测试某key是否在map m中: elem, ok = m[key] //用这种形式的前提是elem和ok已经在前面声明了(如果前面没声明,要写成elem,ok := m[key])；就该例来说，如果key在m中则ok的值为true,elem为相应的值，如果key不在m中，则ok为false, elem为m中元素类型的"零值"
Exercise: Maps
1.练习下一轮的时候再看
Function values
0.functions are values too.
0.从这节的解释说明来看,function value指的是两个函数: 1是作为参数传给高阶函数的那个函数; 2是作为return返回值的那个函数
1.初看，这一块讲的就是python中的decorator,函数即可以作为函数参数，也可以作为函数的返回值   //应该就是其它语言中所谓的高阶函数吧?
2.再看，有一点需要注意的，就是函数作为参数时的写法，这块乍一看不理解，但是分开来想还是可以理解的: func compute(fn func(float64, float64) float64) float64{},分解开看一下:
  func是定义函数的关键字
  compute是函数名
  fn是compute中的参数
  func(float64, float64) float64整体是fn的类型
  *.这点就是我要说的，正常情况下一个函数是由函数名，参数和返回值类型组成的，上面这条完整的表现了一个函数的这几点要素。而fn的类型是函数，所以这样子去理解"fn func(float64, float64) float64"就不难理解了
  *.再看例子，觉得上面这个*说的就有点不对了，"fn func(float64, float64) float64"当函数作为参数时，fn是参数名没错，"func(float64, float64) float64"作为fn的类型也没错，但是注意到一个细节，当函数作为参数类型时，相应的结构中没有函数名，这个是可以理解的，而且形参也是只有类型没有名，这个应该也理解，没了，都可以理解了，最后的那个float64是func(float64, float64)的返回类型
3.还是将tour上的那个例子写在这吧，看着例子好理解一些:
  import (
    "fmt"
    "math"
  )

  func compute(fn func(float64, float64) float64) float64 {
    return fn(3, 4)
  }

  func main() {
    hypot := func(x, y float64) float64 {
      return math.Sqrt(x*x + y*y)
    }
    fmt.Println(hypot(5, 12))
    
    fmt.Println(compute(hypot))  //这块函数引用只用了函数名，需要注意一下
    fmt.Println(compute(math.Pow))
  }
*.关于上面这个高阶函数,还要讲一下传当函数A作为另一个函数B的参数时,在调用时的注意事项,见下面代码main函数中的注释部分:
    package main
    import "strconv"
    import "fmt"
    func A() int {
    	return 86
    }
    func B(fn func() int) string {
    	return strconv.Itoa(fn())
    }
    
    func main() {
    	fmt.Println(B(A)) //方法一,直接传入函数名,切记函数名不要加(),否则被传入的类型就不是函数A了,而是返回值的类型int
    	x := A             
    	fmt.Println(B(x))  //这个方法基本同上,就是给函数A取了个别名
    	y := func() int {return 86}  
    	fmt.Println(B(y))  //这是官文推荐的方法,即不用func声明函数,而是直接将函数作为一个表达式,最终得到一个函数类型的变量y
    }
4.假设A是一个高阶函数,其参数一或是返回值为函数B,当时想即然函数B无论如何也是要在函数A中执行的, 那为什么不直接在函数A中直接调用函数B呢,反而多此一举,先将函数B作为函数A的参数,然后再在函数A中对B进行调用?!, 现在我想明白了, 关键点在于"动态"两个字,假设我们明确知道要在函数A中调用的函数B是谁,那么无论是使用高阶函数还是直接在函数A直接调用函数B都是没有问题的. 但问题是, 我们将函数A给抽象成可以在函数体中执行任何函数B的函数,此时就必须要用高阶函数了,因为我们不知道这个函数B不是个具体的函数了.知道了这点,再一想一下常用的map函数,它接受一个数据集,和一个处理数据集的函数, 此时你再想想, 100个人可能有100种处理数据集的想法, 你怎么能做到直接在map函数中调用一个函数逻辑去满足这100个人的处理逻辑呢?此时只能使用高阶函数,将map函数的参数类型设置成函数类型, 这样你就可以传入任何的函数, 从而可以用不同的逻辑处理数据集. 如果golang本小节是要讲高阶函数,其实它举的这个例子对于理解什么时候使用高阶函数是没有帮助的, 这只谈到了用法, 但这个例子执行完过后,脑子里并不知道什么时候会用到这种结构.
Function closures
1.本节对Function closures的定义是: 引用closing function中变量的function value就是function closure. 因此function closure和function value唯一的区别是function closure的函数体中要引用closing function中和其处于同一级的变量. 而要想让function value函数引用closing function中的变量,应该只有例子中提到的"匿名函数作为return返回值"时,才能办到,因为匿名函数写的时候才会写函数体, 而引用外面单独定义的非匿名函数又不可能访问到function closure的closing function中的变量,因为本地变量的作用域的原因. //还要想一下除了让匿名函数作为return的返回值这种情况,匿名函数体中可以引用closing function中的变量外,还有什么情况可以让function value即有函数体还引用了cloing function中的变量
*.说一下自己理解的function closures的作用吧: 产生自同一个模板的实例,即有自己的逻辑,又有相互关的地方,这种条件下可以考虑function closures. //下面1,2,3,4想删来着,但后来觉得有些东西虽然说的不太准或比较琐碎,还是先留着吧,完全准备好了再删.
1.首先说Go function可以是closure.
2.然后下面解释什么是closure?
3.::closure是一个函数值，我感觉再精确一点，closure就是一个作为(返回)值的函数；但是还有一个约束，就是这个函数返回值的body部分引用了body外的变量，body外应该指的就是和return同级的一些变量；这句话还可以和上一句一样说的更精确一些，closure其实就是一个无名函数，它作为函数的返回值，return的参数。即函数的返回值也是一个函数，但是还有一点需要说明的是不是随便一个被返回的无名函数都叫closure,这个无名函数体内还要引用和return同级的变量才可以；总结一下closure的特点：
  a.closure是一个无名函数;
  b.closure是某个函数的返回值;
  c.这个无名函数体中要引用无名函数体外部的变量 //为什么一定要引用outer变量呢,看下面第4点的b;而且官文中并未说无名函数,而是说的function value的函数体中要引用closing function的变量,但是这么说照目前看按我的知识库来说,就是唯一指的无名函数
  d.closure一般作为return的参数
  *.就上面第3点所述，外部的变量应该指的就是和第4点中return同级的变量
*.这一小节的1，2，3是相关联的，要一起看
4.这节通过例子还是有两点需要注意的：
  a.同时给多个变量赋值，这个其实也不算新东西:
       pos, neg := adder(), adder()    //准确来说应该叫同时声明多个变量并赋值
  b.下面这个例子讲到了精髓,在下面的例子中,所谓的function closure并不是adder()这个函数, 而是它的返回值"func(x int) int",而重点在于返回值中的函数引用了outer的变量sum,而closure function的作用可以理解为: 将外部函数adder理解为一个类,将每次adder()理解为得到一个实例, 类的实例说白了就是在将这个类复制到另外一块内存上嘛.使用adder()多次赋值就会得到多个实例,这些实例之间没有交集,是在不同的内存区域上, 但对相同实例的多次调用时,上一次的调用会影响下一次,因为下一次调用时会引用上一次得到的sum;(这么说可能不是真正的设计逻辑,但是对于前期理解还是有一点帮助的)//这段话要是不明白根据官网例子的结果多推敲一下就明白了
  func adder() func(int) int {
  	sum := 0
  	return func(x int) int {
  		sum += x
  		return sum
  	}
  }
  
  func main() {
  	pos, neg := adder(), adder()
  	for i := 0; i < 10; i++ {
  		fmt.Println(
  			pos(i),
  			neg(-2*i),
  		)
  	}
  }   
Exercise: Fibonacci closure
1.练习部分下一轮再说
Methods and interfaces
Methods
1.Go语言没有类这个概念
2.虽说Go没有类的概念，但接下来引出Go语言有方法的概念，我们知道方法这个词一般是对类中函数的称法；既然Go没有类，那么Go中的方法是怎么实现的呢?简单来说就是在原有函数定义的基础上，在func关键字与函数名之间加一个在Go中被称为receiver的参数，这么个组合在Go中就叫做方法
3.从实例来看，这个receiver仅仅是为函数体提供引用数据，再说白点就是receiver中定义的数据，在相对应的函数中都可以使用
4.下面这段代码叫做:Abs方法有一个类型为Vertex名称为v的接收器:
  type Vertex struct {
    X, Y float64
  }
  
  func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
  }
  将引用的部分也写下来吧，应该有助理解:
func main() {
  v := Vertex{3, 4}
  fmt.Println(v.Abs())
}   //从调用形式来看，和kotlin中类的扩展意思差不多，可以看一下引用，是将Abs()作为v这个类的方法去引用的，而且Abs()函数体可以使有v类中的成员
5.一个简单的例子:
    package main
    import "fmt"

    type Person struct {
    	name string
    	age int
    }
    
    type Car interface {
    	drive() string
    	stop() int
    }
    
    func (p Person) drive() string {
    	return p.name
    } 
    
    func (p Person) stop() int {
    	return p.age
    }
    
    func main() {
    	var YQ Person = Person{"YangQiang",30}
    	var baoshijie Car = YQ
    	fmt.Println(baoshijie.drive())
    	fmt.Println(baoshijie.stop())
    }
上面这个例子就是接interface也给带出来了, 如果要说interface的常用方法,上面这个例子还不够,如果再定义一个type Alien struct{}类型,然后Alien类型再实现drive()和stop()方法,这样,"var baoshijie Car = "后面的值就即可以是YQ,也可以是Alien了,因为这两个类型都实现了Car这个接口的方法,而具体baoshijie的值是YQ还是Alien,就根据实际需求了. //抽象出来说明就是: 接口中定义的方法可以被N多的类型实现, 但不同类型有不同的实现方法, 当一个变量声明为相应的interface类型时, 可以根据实际情况将相应实现其方法的类实例赋给变量.


*.也就是说这节说的receiver, 说白了就是一个"类"!
Methods are functions
1.这一节就着重强调了: method is just a function with a receiver argument
2.拿一个例子来说明了，将method的receiver部分放到function的参数位置，则function和method实现的功能是一样的(不知道是否所有的method和function都可以这样转换，这个后期再讨论)
  type Vertex struct {
    X, Y float64
  }
  方法的形式:
  func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
  }
  引用的时候:
  v := Vertex{3, 4}
  fmt.Println(v.Abs())   //Abs()里面没有参数，因为Abs()函数体可以直接从v中取
                       //这遍看突然发现，方法的引用好像不对，打印函数中参数应该是v.Abs(),现在只写了Abs()  //已在Abs()前补上receiver v补上
  
  函数的形式:
  func Abs(v Vertex) float64 {
    return math.Sqrt(v.X*v.* + v.Y*v.Y)
  }
  引用的时候:
  v := Vertex{3, 4}
  fmt.Println(Abs(v))  //Abs()里面要加参数v,否则函数体中引用的v.X和v.Y就会报错了
*.还是上面说的，就现在的理解method之于function来说只是给function加了一个环境(用环境这个词好像不太形象，理解就好。)，这个环境的数据在function中可以引用，仅此而已(强调：是目前这么理解!)
Methods continued
1.前面讲的方法，接收器的类型是struct,其实对于非struct类型也是可以的
2.receiver的类型必须是在method所在的包内声明，在其它包中声明的类型(包括内建的包)不能作为本包method中receiver的类型  //举例来说, 像int, float64这样的内建类型,因为它们不是在你定义方法的那个包中声明的, 所以你不可以直接将它们作为接收器类型,如果确实想用其它包中或是内建的类型, 首先要保证该类型在本包内可访问(这主要是针对非内建包,因为内建的许多类型所在的包都是默认导入的),然后再使用"type 别名 非本包内声明的类型名"的方式,在本包内声明一下, 然后再使用这个 "别名" 作为某方法的接收器类型就可以了.
3.定义一个类型，使用关键字"type,后接类型名，最后接类型" ,如:type myfloat float64
  type MyFloat float64
  func (f MyFloat) Abs() float64 {
    if f < 0 {
      return float64(-f)
    }
    return float64(f)
  }
Pointer receivers
1.这一节的节名叫"指针接收器"，该指针和c中的指针意思是一样的，后面应该会讲Go里没有指针之间的运算
2.其实重要的是要理解指针的概念，指针的概念弄明白了，这一节自然也就没啥了.首先内存说起，内存是一个地址空间，可以把内存想象成一个大房子，里面有N个房间，每个房间都有自己的编号,1,2,3...,再来说变量，编程语言中声明一个变量，其实就是在内存中给这个变量分配一块空间，空间大小由变量的类型决定。变量声明其实最终这个变量得到的是一个内存中的地址，拿上面的房间举例来说就是，var a int,对应下来可能就是将第一间房间的房号1给变量a,而第1，2，3，4间房是分配给a的空间，以后再给变量a赋值时其实是先定位到1这个位置，然后向1234这四个房间记数据，从a中取值也是，先定位到1这个位置，然后把数据取出来；下面该说指针了，这个指针对应的就是这个位置1，说白了就是指针其实就是内存中的地址。而指针变量就好理解了，就是这个变量中存的是指针，再换个说法变量中存的是内存中的地址。而指针变量前加上*，指的就是指针变量中的地址指向的值，这句说的不太明白，举例来说，变量a在内存中的地址是1，变量a的值是"abc",有一个指针变量b,b中存的是a的地址，则b的值是1，*b是"abc"(即指针变量b的值a所指向的内存空间的内容)
*.指针这个东西其实只要明白了内存结构，还有声明变量的实际情况就很简单，有时间要回看一下王爽的16位汇编。上面这些描述不是太准确，只能帮助理解一下
3.Go中指针最重要的一点就是，接收器如果是指针引用，则会修改指针变量值所指向的实际内容。下次再引用该指针变量值的时候，该指针变量值的指向就已经是修改后的了；如果接收器就是普通类型的变量，则方法中引用该接收器变量内容实际上是先对该内容做个备份，然后引用的是备份的内容。下次再使用该接收器的变量时还是原值，因为之前根本就没有对接收器的原始值做修改
*.这一节说的就比较不太好了，后面有机会这块用心再总结一下
4.这节的例子，如果Scale接收器的类型为Vertex则最后的值是5，如果是*Vertex最后的值是50   //我的理解是，本质上还是对类的操作，我们可以将最开始声明的类理解为"模板"，将类的实例化理解为"复制一份模板并自定义相应的修改"，指针类型的接收器特点是:"不是在copy的模板上修改，而是直接修改类声明的数据，即直接修改原模板的数据"，而普通类型的特点是"将原模板复制一份，然后在复制后的模板上做修改，即原模板的数据不会被改变"，此时再去这小节的例子就可以理解了，再啰嗦一句:指针作接收器是在内存中声明类时分配的内存区上直接作修改；普通类型作接收器是将声明类时内存区中的数据复制一份到另一块内存上，然后在复制的这块内存上做修改，并不会影响类声明时分配的内存区上的内容；其实平时说的"类的实例化"的行为应该和这里说的普通接收器的行为一致.
5. receiver type如果是指针的话，不能是*int,*float64这些，必须是 type a float64,这里*a可以作为receiver type; 我不知道原文件咋翻译  //也可以理解为系统内置的类型不能直接作为指针接收器的类型，即要不自定义一种类型，要不将这些内置的类型再封装一层才能做指针接收器类型
6.func (v *Vertex) Scale(f float){}读作:定义在*Vertex类型上的方法
7.接收器的类型为指针的话，对该针指的指向进行修改，修改的是原始位置，即后面再引用该指针的时候，使用的值是之前修改过的；但接收器的类型为普通类型的话，则修改的是这些变量的备份，不会影响原值；普通函数的参数类型就属于这种(修改的是副本)
Pointers and functions
1.这节主要看的是例子，method用function实现，其实也就是将method的receiver部分给放到function参数的位置    //需要注意的是Scale()函数中第一个参数值为&v,因为指针变量存的实际上是另一个类型的地址，所以这里用到了&符号
Methods and pointer indirection
1.function中的参数是啥类型，调用该function时参数类型绝不能写错(这个不像receiver中的类型，明明类型是指针或是普通类型，但调用的时候可以使用普通类型或指针进行调用，Go优化了这部分逻辑)  //我写这句话其实是为了强调一开始讲指针时的一个调用例子，即本应该是(*p).X,但在Go中直接写p.X就好！但是如果指针作为函数参数而非接收器时，在调用函数时，该参数一定要用指针调用的形式而不能用普通变量调用形式(其实关键点就是那个&符号，指针参数有，而普通类型的参数没有)
  var v Vertex
  ScaleFunc(v, 5)  // Compile error!
  ScaleFunc(&v, 5)  // OK
2.上面1说了，当方法的接收器类型为指针时，引用方法的时候，接收器可以使用value(普通类型),也可以使用pointer(地址)  //猜测Go在处理指针类型的接收器调用函数时，如果你没在指针变量前加&的话，Go会隐式的帮你加上，这个行为猜测是编译阶段编译器处理代码时给自动加上的；但如果指针作为函数参数时，猜测由于Go语言没有在编译阶段加上这个逻辑，所以在函数调用时，如果函数参数为指针类型则一定要使用&符号，其实感觉函数参数如果是指针类型也可以处理一下，无非是处理之前先检测一下类型呗，当然啊这句注释完全是为了好理解的一个猜测.
  var v Vertex
  v.Scale(5)  // OK
  p := &v
  p.Scale(10) // OK
  *.作为约定,Go在解释v.Scale(5)的时候会自动解释为(&v).Scale(5)
3.还要注意指针中&号与*号的简单作用，给个简单例子看一下吧:
    package main
    
    import (
    	"fmt"
    )
    
    var x = 5
    
    func main() {
        var p = &x
    	
    	fmt.Println(x)
    	fmt.Println(p)
    	fmt.Println(&x)
    	fmt.Println(&p)
    	fmt.Println(*p)
    	fmt.Println(*(&x))
    	fmt.Println(**(&p))
    }
    输出为:
    5
    0x190004     //这几个地址每次输出的值可能会不一样
    0x190004
    0x40e128
    5
    5
    5
Methods and pointer indirection(2)
1.上面也提过，function参数是啥类型调用时就得使用啥类型
  var v Vertex
  fmt.Println(AbsFunc(v)) // OK
  fmt.Println(AbsFunc(&v)) // Compile error!
2.但是method不一样，method中接收器的类型为value时，调用该method时也是即可以使用value也可以使用pointer类型
  var v Vertex
  fmt.Println(v.Abs())  // OK
  fmt.Println(p.Abs())  // OK
  *.p.Abs()会被解释为(*p).Abs()
**.对上两小节的主要内容总结一下吧:
    1.无论方法的接收器是value类型还是pointer类型，在进行调用时都可以使用value类型或是pointer类型进行调用, 编译器会进行相应的转换
        a.接收器为value类型,则如果使用&p进行调用，则编译器会将&p转化为*(&p)
        b.接收器为pointer类型，则如果使用v进行调用,则编译器会将v转化为&p
    2.接1说，但是函数定义中的参数如果是value类型则传参时必须是value类型，如果是pointer类型则必须传pointer类型  //这个就不说了上面都有例子
**.同样使用例子和说明再做个总结吧,没有包含函数定义时参数引用情况,这个上面也说了,必须精确传递,参数是啥类型就要传啥类型:
  /*当接收器类型为指针时,在调用相应的方法时,无论你是使用指针类型进行调用还是使用值调用,调用结果是一样的,都遵循"方法定义时所使用的接收器类型". 换句话说,当接收器炎指针类型时,如果你使用指针类型调用,正好,这是常规逻辑; 如果你使用的是值调用,则在真正执行的时候,编译器也会根据相应的方法在定义时前面的接收器类型,给你的值调用前加上个"&",然后再进行执行. 也就是说,当接收器为指针类型的变量时, 你在调用相应的方法时,无论是使用的值调用还是指针调用,最后执行的语句都是一样的,即都是指针调用,因此得到结果也是一样的.就下面的例子而言,ZS声明时的类型为普通Person类型,当你引用的时候写的是:
ZS.multiply() 时, 在执行前会检测multiply()方法定义时的接收器类型,将该句处理为:(&ZS).multiply(),然后再执行.
而当你写的是: (&ZS).multiply()时,同样在执行前还是会检测multiply()定义时接收器的类型,发现没问题,则预处理对它啥也不做,原样执行.
也就是说: 关键点在于golang在调用方法的时候,会根据方法在声明时接收器的类型去调整你实际调用时使用的变量类型.
    func (p *Person) multiply() {
    	p.name = p.name + "-"
    	p.age = p.age + 3
    }
    
    func main() {
    	ZS := Person{"zhangsan",18}
    	fmt.Println(ZS.name, ZS.age)
    	ZS.multiply()  //ZS-> (&ZS)
    	fmt.Println(ZS.name, ZS.age)
    	ZS.multiply() //ZS-> (&ZS)
    	fmt.Println(ZS.name, ZS.age)
    }*/
  /*下面的multiply()方法的接收器是普通类型,而下面的mai()函数中,ZS变量是指针型变量,此时当我们在调用multiply()方法时写的是:
    ZS.multiply(),则编译器会根据multiply()方法在定义时前面接收器的类型,自动将指针类型引用转为值引用,即改为: (*ZS).multiply().
    如果你在调用multiply()时,直接写的就是(*ZS).multiply(),则编译器同样还是在执行该句前检测multiply()方法定义时的接收器类型,发现调用的类型和定义时的一样,则不会更改什么,原样执行
    func (p Person) multiply() {
    	p.name = p.name + "-"
    	p.age = p.age + 3
    }
    
    func main() {
    	ZS := &Person{"zhangsan",18}
    	fmt.Println(ZS.name, ZS.age)
    	ZS.multiply()  //ZS-> (*ZS)
    	fmt.Println(ZS.name, ZS.age)
    	ZS.multiply() //ZS-> (*ZS)
    	fmt.Println(ZS.name, ZS.age)
    }*/

Choosing a value or pointer receiver
1.这一节说出了在声明method时使用指针作为接收器类型的两点原因：一是，可以直接修改pointer指向的值；二是，避免了方法调用时要先做备份，然后对备份修改时的性能损失(接收器类型为value时,使用value类型的变量对方法进行的调用不是要先将value类进行copy,得到一个value类型副本,然后在副本上进行操作嘛,这样一来,如果value类型数据较大,则性能损失比较严重. 话又说回来了,各有优缺点, 使用value做为接收器时,不同的value类型的变量之间没有影响,因为每个value类型变量在调用相应的方法时都会先copy一个自己的value类型副本)
2.通常来说相同类的receiver类型不能同时存在，不能混用,即如果有func (a A) x,则以后类型A只能以value类型作为方法的接收器, 不能出现func (a *A) y这种形式, 反之为然. //本节并没有说明为什么不能混用,说在下面几节能找到原因. 我写代码实际测了一下,编译这块并没有什么问题,一个是(a A),一个是(a *A)编译执行也都是没问题的.
3.为了弄求清上一条2所说的在编写代码时最好(同一个类)接收器的类型(value,pointer)不要混用,总结了一下:
    /*
    1.当未引入接口类型时,某个方法的接收器类型无论是value型还是pointer型,在调用的时候你都可以使用value型或pointer型进行调用(具体为啥上面已有详解).
    2.当引入接口类型时,变数就来了, 这里要分为两种情况:
        a.不显式的引入接口类型变量(或称为不将接口类型与接收器类型相关联), 此时可以忽略接口对方法进行调用,而且无论方法定义时用的接收器类型是value还是pointer,调用时还是上面讲的常规调用,即使用value或pointer都可以.
      type V struct {X,Y int}
      type I interface {ok() int}
      func (v V) ok() int{  //这里的接收器无论是V还是*V,由于主函数中没有引入接口类型I,而是直接调用的方法,所以,见下面注释
    	  return 666
      }
      func main() { 
        //var i I
        a := V{1,2}  //这里的值用value,V{1,2}或pointer,&V{1,2},都是没问题的,下面的fmt调用都不会出错.
        //i = a
        //fmt.Println(i.ok())
        fmt.Println(a.ok())
         
      }
        b.显式的引入接口类型变量(或称为将接口类型与接收器类型相关联), 此时
              <1>.方法定义时接收器的类型为value时,基本同上, 即,既可以将value型变量赋给接口类型变量,也可以将pointer类型赋给接口变量,最后使用接口变量对方法进行调用
      type V struct {X,Y int}
      type I interface {ok() int}
      func (v V) ok() int{  //因为实现接口I的ok方法时用的接收器为value,所以,见面注释
    	  return 666
      }
      func main() { 
        var i I
        a := V{1,2}  //这里的值用value,V{1,2}或pointer,&V{1,2},都是没问题的,下面的fmt调用都不会出错.
        i = a
        fmt.Println(i.ok())
         
      }
              <2>.方法定义时接收器的类型为pointer时,特例就来了,此时只可以将pointer类型的变量赋给接口类型变量,然后使用接口类型变最对方法进行调用; 如果此时将value类型的变量赋给接口类型的变量,则会报错(说value类型未实现接口).
      type V struct {X,Y int}
      type I interface {ok() int}
      func (v *V) ok() int{  //因为实现接口I的ok方法时用的接收器为指针类型,所以,见面注释
    	  return 666
      }
      func main() { 
        var i I
        a := &V{1,2}  //这里的值必须要用指针,如果将"&"去掉,下面fmt中的调用就出错了
        i = a
        fmt.Println(i.ok())
         
      } 
但虽说混用时,只能将pointer类型赋给接口变量,但使用指针变量进行调用时,接收器类型是指针的,在原接收器类型对象上修改,接收器类型是value的,则还是在副本上修改,这一点和我想的不一样, 原来我想的是指针变量都是pointer类型了,肯定无论实现接口中方法的接收器是value型还是pointer型都在接收器对象原位置修改.现在想来golang尊重的是方法声明时接收器的类型:
 type V struct {X,Y int}
  type I interface {
	  ok() int
	  yes() int
  }

  func (v V) ok() int {   //接收器为value
      v.X = v.X*10
      return 0
  }

  func (v *V) yes() int {  //接收器为pointer
    v.Y = v.Y * 10
    return 0
  }

  func main() {
	  var i I
    r := &V{1,2}  //因为上面混用,所以这里只有将指针类型值赋给r才合法
    i = r
    i.ok()  //作用在v副本上
    i.yes()  //作用在v原位置
    fmt.Println(r.X)  //输出1
    fmt.Println(r.Y)  //输出20
  }

*/  
结论:那么到底为什么不能混用呢? 既然上面这段代码已经证明了,既使V和*V混用去实现一个接口,只要在给接口变量i赋值时赋指针值即可,因为r在调ok()时改的就是r的副本,在调yes()时就是在r原位置改的.所以逻辑都是通的怎么就不能混用了呢?  在stackoverflow找了个相关的链接,状态好的时候可以看一下,可能会有答案,同时里面还给出了什么时候使用value receiver什么时候使用pointer receiver( https://github.com/golang/go/wiki/CodeReviewComments#receiver-type): https://stackoverflow.com/questions/27775376/value-receiver-vs-pointer-receiver/27775558#27775558
Interfaces
1.首先Interface是一种类型，在定义Interface类型的时候，body中是N多方法的集合，需要注意的是:body中的这些方法只有方法名及相应的返回值类型，并没有方法的具体实现
  type Abser interface { Abs() float64 }
2.根据例子来看，interface类型的用法一般是：首先要明确一点，interface类型body中的不是function,而是method(即带有receiver的function);其次和interface这节没关系，要说的是method的常用调用方法是 "receiver.method_name()",方法最常用的形式大概是"多个同名不同receiver类型的方法"，虽说调用的形式都是相同的,但编译器会根据receiver的不同，从而选择相应的method执行，这个看看本节的例子很好明白
3*.对于理解比较重要的一句话是:"A value of interface type can hold any value that implements those methods"，翻译过来是"给接口类型赋的值，可以是实现接口中方法的任何值"，如果前面method相关章节中没有好好看，好好理解的话，这句好可能会有些不明所以；我们知道所谓的方法(method)，就是带有接收器(receiver)的函数(function)，而其中有一些描述方法的话，大概意思是"接收器(receiver)类型实现的方法(method)"; 然后再看上面的那句话，应该就能明白了，举个例子:
  a.如果定义了一个接口类型Abser,里面的方法特征是: Abs() float64,就这一个方法
  b.定义一个Abser类型的变量a  "var a Abser"
  c.此时变量a的合法赋值，要看具体Abs()方法实现的时候，接收器都是啥类型的，假如声明了两个方法，一个是"func (v *Vertex) Abs() float64 {}",另一个是"func (f MyFloat) Abs() float64 {}"，则在给a赋值时，只有类型是*Vertex和MyFloat的才合法。这是为什么呢？因为你后面要使用a.Abs()进行调用，如果a是除*Vertex和MyFloat之外的其它类型，则在调用时是会出错的，因为你没有定义接收器是其它类型的方法(这个在编译的时候编译器会检测a值的类型，是否有该类型实现了Abs()方法，如果有则通过，如果没有则报错)
*.其实想想，肯定是有逻辑在里面的，首先interface类型中声明了N多个(N大于等于1)方法特征(基本上就是方法名，还有返回值类型)；再者你在interface中声明了方法后，后面肯定是要实现的，不实现的话，interface类型中定义的方法特征就没意义了；再者你方法实现了的话，肯定又是要引用的，不引用的话，你实现的方法又没意义了；而方法的引用一般是"接收器类型的变量.方法名"；而给interface类型的变量赋值这块，你想想这个变量的类型是啥呢？其实结合上面这些因素，interface类型的变量被赋值的类型是实现接口中定义的方法的接收器类型是最合理的。(最后一句话对于理解很重要)
Interfaces and implemented implicitly
1.我们平时所说的"类型实现接口"是指"类型实现接口中定义的方法"
2.在"类型实现接口方法"时，是隐式的，没有显示的关键字来说明"类型实现接口方法"
3.类型对接口的隐式实现，好处在于将定义与实现分离了，也就是说对于接口的定义你可以放在任何包中，然后在不同的包中你可以对接口有不同的实现(这块还是要再啰嗦一下，一定要注意从接口的声明，到使用的步骤:1.肯定是先定义接口;2.实现接口中的方法，这时要注意Go中的方法其实就是函数加个接收器，而接收器的形式是"接收器名 接收器类型"；3.定义接口类型的变量，这里要尤其注意，这里的"接口类型"指的是实现接口中的方法时的"接收器类型"，即如果接收器类型是int,你在定义接口变量时给了一个float类型，编译时是会报错的；4.其实接口这块还是有一点点绕的，接口中的一个方法，在实现时，可以根据"receiver类型"的不同有多个实现方法，而在给接口变量赋值时，变量的值一定要要是已经定义过的方法中定义的"receiver类型"，否则会出错，这个可以参考上一节“Interfaces”的例子来理解一下
*.因为接口用的还少，目前看来感觉接口就是"定义一个或多个方法，但是并没有实现"，好处是你可以将这个接口放在任何包里，因为本来也不带实现代码，所以在哪个包里放着都一样；好处是你可以在不同的包里对接口里的方法有不同的具体实现，且被实现的方法中"receiver类型"也可以是不一样的；说白了就是灵活性增强了。现在虽然说勉强会用接口了，但是因为实现的代码少，总是隐隐觉得不安，觉得理解的还不够透彻。
Interface values
1.这节的标题叫"Interface values"，相应原文大概要表达的意思:a.interface value可以被认为是一个由"值"和"值相对应的实体类型"组成的"元组"， 说白了就是(value, type)  //这个(value, type)只是为了让我们好理解的一个假想,举个例子吧, 
    type i I {ok() int}
    type V struct{X int}
    func (v V) ok() int{}
    var i I
    r := V{1}
    i = r
    i.ok()
    上面代码中,所谓的(value,type)指的就是(i, r或是V{1}还是就是V呀)
2.这里面还有一个字符串叫"underlying concrete type"， 这个玩意可以用上面接口例子中的内容去理解，即接口中只定义了方法名，下面要实现该方法，而方法是有接收器(receiver)的，一旦方法实现了，再给相应接口类型的变量赋值时，只能赋实现方法时所使用的接收器的类型的值，用其它类型的值就会报错，而这里开头说的"underlying concrete type"指的就是这个实现接口中方法的接收器(receiver)类型
3.最后一段话初看者其实不好理解，说的是在"interface value"上调用一个方法，会在"interface value"相对应的"underlying type"上执行相同方法名。从例子上看，其实就是为了表达，如果定义了一个函数，函数参数是接口类型，则传参的时候，传递的这个参数必须是实现接口中方法的接收器(receiver)的类型(对于该节右侧的例子来说，应该"i"是"interface value", 而"*T"和F是"underlying type")
Interface values with nil underlying values
1.先要明白标题指的是什么东西，举例来说:
type I interface { M() int }
type T struct { S string }
func (t T) M() int {}
var i I
var t1 T
i = t1
t1.M()
首先说上面这段代码是错误的,因为struct和map,slice不同,struct只声明不赋值时,默认0值不是nil,只有所有的指针变量不赋值时都是nil,所以上面代码要改为:
type I interface { M() int }
type T struct { S string }
func (t *T) M() int {}
var i I
var t1 *T
i = t1
t1.M()
也就是说这节主要是针对map,slice和所有类型的指针变量来说的.
2.interface value如果保存的实体类型的值是nil,则这个interface value也不是空的。通过例子来看:
    type I interface {ok() int}
    type T struct { S int }
    
    func (t *T) ok() int{
    	return 666
    }
    func main() {
    	var i I
    	var t1 *T
    	i = t1
    	if t1 == nil {   //此处为t1 == nil时,条件是成立的,因为结构体指针t1没有被赋值,如果换成i,则i == nil是不成立的.但是从输出结果来看i和t1输出的都是<nil>,这块有点不太理解内部是怎么实现的
    		fmt.Println("nil!")
    		fmt.Println(i)
    		fmt.Println(t1)
    	}
    }

Nil interface values
1.标题所谓的"nil interface values"说白了就是没有对接口里的方法进行实现，就直接调用参数是接口类型的变量，这样会产生一个run-time错误。接着说之前说过"interface value"其实就是一个tuple (value, type)，而这个type是通过实现接口中的方法来得到的，如果没有实现接口中的方法，则interface values就是所谓的nil
The empty interface
1.空接口比较好理解，指的是按口里面没有定义方法，即就是一个type I interface{ }, 空接口可以保存任何类型的值，因为任何类型都至少实现了0个方法
2.空接口常用于编码处理一些未知类型的值，例如fmt.Print函数就可以带有类型为interface{}的任何数量的参数
3.上两句都可以不看了，说白了就是如果之前定义了一个变量I为空接口类型， type I interface{}， 而且定义了一个参数为空接口类型的函数，则调用这个函数时，可以使用任何值作为这个函数的参数，无论这个值是什么类型，因为前面说了，任何类型都至少实现了0个方法  
***
接口这一节主要是要弄清几个单词的内容:
1.Interface values      // (value, type)
2.nil underlying values   //简单来说就是给指针变量赋值了, 但是赋的是一个未初始化的值. (所谓nil underlying value,首先是对接口而言的,而underlying type指的是实现了接口中方法的那个类型, underlying value自然指的就是实现了指口中方法的那个类型的值了, 而现在这个值是nil,说明我们给这个underlyig type变量只声明了, 未赋值. 这么说是不完全正确的,正确的应该是: 对于slice类型和map类型,和其它类型的指针类型(即类型为map[T]S, []T, *int, *float64等是正确的),因为一般的类型你只声明不赋值都会有一个0值,这个零值除了刚说的那几种是nil外,都不是nil.
  var i I  //定义接口变量i
  var t T //定义T类型变量t,其中T实现了I中的方法
  i = t  //将T型t,赋给I型i
  i.方法()  //此时用i调用实现的方法时,i的值就是nil,因为function value一节说了, 使用接口类型变量调用方法,实际上用的是underlying type去调方法.而此时如果underlying type只初始化没赋值,并且其zero值正好是nil,就是本节讲的内容了.)
3.nil interface values   //通过看官文的例子,觉得nil interface values指的是接口中的方法没有被实现.现在再细想,其实重点不在这. 首先,对于nil interface values来说,大的概念还是interface value, 而interface value 说白了就是var i I中的i, 而nil interface value指的就是声明了接口变量,但没有给接口变量赋值,此时的接口变量的默认值就是nil,和上面有没有某个类实现了接口中的方法无关. 而调用没有初始化的接口会报错.
4.empty interface   //这个没啥说的就是接口定义时没有定义方法
***
Type assertions
1."类型断言"的作用是判断最后一次赋给接口变量i的值,其类型是否为某个实现了接口方法的类型n.也就是说这个"类型断言"这个功能成立的必要条件是: 类型n已经实现了接口I中的方法. 我想到的使用场景: 有多个类型X,Y...都实现了接口I中的方法, 然后在代码中使用i.(n)去判断当前接口变量i中存放的是不是这个类型值.换句话说判断的是最近一次给接口i赋的值的类型是否为n.
  *.其中有个特殊情况就是有多个类型都实现了接口I,但并未将任何一个相应类型的值赋给接口变量i.
2.上面1中说的是我想到的场景,而落实到代码上时,有两种形式:
  a.1个返回值: t := i.(n)   如果最近一次接口变量i的值类型为n,则将最近一次赋给i的值赋给t,否则发生panic.
  b.2个返回值 t,ok := i.(n) 如果最近一次接口变量i的值类型为n,则将最近一次赋给i的值赋给t,将布尔值true赋给ok, 否则将n的零值赋给t,将false赋给ok,并且不会发生panic
*.再加一句吧, 上面已经说了类型n必须是实现接口I中方法的.如果你随便用一个未实现接口I中方法的类型去替代n,则会报错告诉你,你所用的这个类型未实现接口I.
Type switches
/*这里的switch的作用是在一个结构中判断当前接口i中存放的到底是哪个类型(假设已经有多个类型已经实现了接口中定义的方法)的值. 而每个case T,就是一个判断条件.当接口变量i当前存在的值类型为某个关键字case后面的T,则执行相应的代码.如果接口变量i中存放的类型和任何一个关键字case后的类型都不匹配,则执行default关键字下面的代码.
而在落实到代码上时, 还有两种情况:
  a. 当switch条件部分没有变量部分时,仅仅是做类型的匹配以及执行匹配上类型的代码块;
        type I interface {ok() int}
        type T struct {S int}
        
        func (t T) ok() int { return 666}
        
        func main() {
        	var i I
        	t := T{2}
        	i = t
        	switch i.(type){   //因为i.(type)前面没声明变量,因此代码中不可引用i.(type)的返回值
        	case T:
        		fmt.Println("T")
        	default:
        		fmt.Println("other")
        	}
        }
    b. 当switch条件部分有变量时, 如果某个关键字case后面的类型T匹配上了,则变量的类型为T,值为当前接口类型值; 如果所有关键字case后面的T都未匹配上,则变量的类型和值同接口变量相同.
-----当前接口变量值的类型和某个case后面的类型匹配-----
        type I interface {ok() int}
        type T struct {S int}
        
        func (t T) ok() int { return 666}
        
        func main() {
        	var i I
        	t := T{2}
        	i = t
        	switch v:=i.(type){  //这里将i.(type)的返回值赋给变量v,后面在case或default语句块中可以引用这个变量v. 在这里因为case T被匹配上了,所以变量v的类型为T,值为当前接口类型值T{2},即 var v T = T{2}
        	case T:
        		fmt.Println("T")
        		fmt.Println(v)
        	default:
        		fmt.Println("other")
        	}
        }
-----当前接口变量值的类型和所有case后面的类型都不匹配-----
        type I interface {ok() int}
        type T struct {S int}
        type Q struct {S int}
        
        func (t T) ok() int { return 666}
        func (q Q) ok() int { return 666}
        
        func main() {
        	var i I
        	t := Q{2}
        	i = t
        	switch v:=i.(type){  //这里将i.(type)的返回值赋给变量v,后面在case或default语句块中可以引用这个变量v. 在这里因为case T没有被匹配上了,所以变量v的类型和值同i,即, var v Q = Q{2}, 这里要注意了,如果你要说i的类型为I就没啥意义了, 要用i的underylying type和underylying value才有意义.
        	case T:
        		fmt.Println("T")
        		fmt.Println(v)
        	default:
        		fmt.Println("other")
        		fmt.Println("v = %T\n",v)
        		fmt.Println("i = %T\n",i)
        	}
        }
    *.上一节讲"类型推断"时,可以有两个变量, 但该swtich结构中只能有0个或1个变量.
    *.另外,如果想判断某个变量到底是什么类型,可以通过fmt.Printf("var_name = %T\n",var_name)的方法;还可以通过引入reflect包,然后使用fmt.Println("var1 = ", reflect.TypeOf(var1))或fmt.Println("var1 = ",reflect.ValueOf(var1).Kind()).而且头两种输出一样,第三种稍有不同,如头两种输出[]int,第三种输出的就是slice(变量类型输出的方法参考自: https://www.geeksforgeeks.org/different-ways-to-find-the-type-of-variable-in-golang/)
*/

Stringers
1.这节主要讲的是fmt包中定义了一个名为Stringer的接口,type Stringer interface {String() string},而fmt包中所有的打印函数以及某些包的打印功能,其实调的都是Stringer接口中的String()函数. 重点来了, 所以如果我们想要自定义A类型值和B类型值的打印内容,就可以使用A和B分别实现Stringer接口的String()函数,这样我们在使用类似于fmt.Println(A,B)的时候,实际上执行的是A.String(), B.String().下面通过一个例子看一下
    type Person struct { Name string, Age int }
    func (p Person) String() string { return fmt.Sprintf("%v (%v years)", p.Name, p.Age) }   //Person类型实现了fmt包中Stringer接口中的String()方法
    func main() {
        a := Person{"Arthur Dent", 42}}   //得到Person类型变量a
        z := Person{"Zaphod Beeblebrox", 9001}  //得到Person类型变量z
        fmt.Println(a, z)  //该句在实际执行的时候,其实执行的是a.String()和z.String()
*.官文中还讲了实现String()方法以达到自定义输出内容格式,在写go代码时十分常见.
Exercise: Stringers
1. 下一轮统一看Exercise
Errors
1.Go程序使用错误码来表达错误
2.和fmt包中的Stringer接口一样，error类型也是一个内建的接口(是fmt包内建还是其它包的?)，即在某个包中有如下定义:
    type error interface { Error() string }
3.和fmt包的Stringer接口类似，当要打印错误信息时，fmt包会寻找error接口来打印错误值(其实并不是打印错误值，而是打印时会先根据参数的类型去先调用fmt内建的相应接口先处理一下，然后将返回值再继续作为打印的参数，所以函数并不是打印错误，而是检测到参数的类型是error接口类型了)
4.函数通常除了会返回正常的返回值，还会返回一个错误值(这句话说的80%不对，可能只是当函数全部执行完成后会返回一个正常值，或是执行过程中出错返回一个错误值，并不是返回两个值，现在还有些理不清(从后面这句话中的例子来看，应该还真是返回两个值))，当这个错误值是nil的时候说明函数返回是正常的没有错误，反之，当返回的错误值不是nil时，说明有错误发生。而一般常用方法是i, err := strconv.Atoi("42"),即函数的返回值可以是两个，一个是正常的返回值，还有一个是错误值，通常在函数在执行完成后，会跟一个if条件语句来检测err的值(是否为nil?等于nil执行啥？不等于nil执行啥)从而来进行错误处理(4这段会误导别人，尽快弄清改正)
*.对4这段的说明：突然想起来了，其实函数可以返回任意多个值，基本上就是一个值，可以通过指定返数的返回值类型来指定多个返回值,如(int, float),文中有两个返回值应该是函数定义的时候显示的指定了返回两个值(这句话值得商榷，例子中可能是定义了两个返回值，但正常情况下是返回几个呢?要严谨的试一下)
5.err为nil表示函数执行成功，非nil表示函数执行失败(官文只说是成功和失败，并没有说是函数的成功和失败，所以这块还要随着练习的加强来确定成功与失败是否指的是函数)
6.因为error也是一个接口(方法)，而错误的输出是调用这个接口(并不是错误的输出调用这个接口，而是变量的类型是error接口类型会调用error接口)，所以我们可以自定义error接口中的Error()方法，来自定义错误输出的内容与格式
7.好像现在明白了，关键点在于，run()函数的返回类型是error,所以在fmt.Println(err)的时候，检测到err是error类型，则去调用上面Error()方法的实现(继续观望)
8.通过试验发现：在使用fmt.Println函数时，首先会检测函数中参数的类型，然后去调用fmt内建的Stringer()接口中的方法，将返回值返传回来，再继续将返回值作为参数打印，error()接口应该也是一样的，当fmt.Println函数检测到参数类型是接口类型时，会先调用相应的接口返回一个值，将这个返回值再作为fmt.Println的参数继续参与fmt.Println的打印(可以参见18节"Exercise: Stringers"一节的例子看一下，补充一个func (ip IPAddr) String() string { return "1234" }, 然后在最后一句对ip的格式化参数后加上123，即fmt.Printf("%v: %v123\n", name, ip),执行后你发现对ip参数的打印是"1234123",从这个结果就可以看出来，在最后一句fmt.Printf函数打印之前，是先对ip调用了内建的Stringer接口，然后将相应的返回结果返回给fmt.Printf作为参数继续打印，才能得到"1234123"这样的结果)
Exercise: Errors
1.下一轮做该练习
Readers
1.小节标题为"Readers"可以理解为读取器
2.io包中，有一个名为Reader的接口，并且在io包中对该Reader接口作了实现: func (T) Read(b []byte) (n int, err error) {}; (官文说Go的标准库中包含了许多对这类接口的实现，说白了就是包含许多相应的方法(methods), 所谓实现不就是实现接口中的方法嘛)。该Read()的理解：它的返回值有2个，一个是进入[]byte中元素的个数(整型)，另一个是错误值(error接口类型)。官文说Read方法是位于带有数据的byte分片中([]byte),然后监控每次进入[]byte的元素个数，返回时将本次进入[]byte中的元素个数以整型返回，并且返回一个类型为error接口类型的错误值，如果没有错误返回nil,如果没有元素进入，则返回的两个值，一个是0，一个是EOF。通过这节带的例子最好理解了:
import ("fmt"; "io"; "strings")
func main() {
    r := strings.NewReader("Hello, Reader!")
    
    b := make([]byte, 8)    //定义一个长度为8个字节的数组b  //应该不是数组，是slice吧?
    for {     //循环读取r中的数据，每次最多8个字节，直到读取完毕
        n, err := r.Read(b) //注意Read()方法的用法
        fmt.Printf("n = %v err = %v b = %v\n", n, err, b)
        fmt.Printf("b[:n] = %q\n", b[:n])
        if err == io.EOF {   //当到达结尾则执行break退出循环
            break
        }
    }
}
执行结果:
n = 8 err = <nil> b = [72 101 108 108 111 44 32 82]
b[:n] = "Hello, R"
n = 6 err = <nil> b = [101 97 100 101 114 33 32 82]
b[:n] = "eader!"
n = 0 err = EOF b = [101 97 100 101 114 33 32 82]
b[:n] = ""
从结果中解读:循环第一次执行，n, err := Read(b)这句执行完成后，b中被读入8个字节，因为没有任何错误，也没有到达字符串的结尾，所以n = 8 err = <nil>，b中的字节为"Hello, R"这8个字符的ascii值；到此第一次循环导致的头两行输出应该没啥疑问; 继续，此时"Hello, Reader!"这个字符串中的字符仅剩下"eader!"这6个字符了；当第二次循环执行完n, err := Read(b)后，字符串剩余的6个字符被读入数组b，从前向后进行覆盖填充，所以你会看到结果输出的字节最后两个是一样的，因为第二次读取只剩下6个字符了，覆盖填充的时候，只能覆盖数组b的头6个字节；到这第三四行的输出应该也没啥疑问的了；继续，此时字符串为空了，第三次执行循环，当n, err := r.Read(b)执行完成后，因为没有字符进入数组b,所以Read()自然监听数组b的进入字符数是0，则n = 0,因为已经到了字符串的结尾，所以err = EOF,此时字节数组b中还是第二个循环中的内容，所以打印出来的ascii值和第二次循环是一样的。
*.感觉有一点需要注意一下，就是第二次明明就将字符串中的字符给读取尽了，但是得到的错误值还是<nil>而不是EOF,所以暂且猜测，一次读取时，只要还能读取到数据，虽然已将字符串读空了，但此时的err返回值依然是<nil>,只有在某一次循环中，从指定对象中一个字符也读不出来的时候，才会返回err为EOF
Exercise: Readers
1.下一轮
Exercise: rot13Reader
1.下一轮
Images
1.没看太明白，也推到下一轮吧
Exercise: Images
1.下一轮
Goroutines
1.轻量级进程
2.协程的声明外形看就是一个函数
3.协程的运行是在函数前加上go
4.协程运行是在新的协程中  //参考kotlin,猜测go fun()就是将协程放进队列
5.多个协程运行在同一个地址空间，所以访问数据时注意synchronous问题
6.sync包
7. youtube中看到可以使用delve调试go,但不知道能否调试goroutines, kotlin中提供的调试就很好用，看输出一目了然
8.看例子执行过程可以明白. 全程只有一个主线程在执行，且time.Sleep()是线程阻塞的
Channels
1.通道就像一根管子，可以接收或发送数据
2.通道符号是 "<-"
3.使用make(函数?类?)声明一个通道 ch := make(chan int)
4.发送接收数据的一般形式: a.将数据送入通道: ch <- v;
                          b.从通道读取数据: v:= <-ch;
5.默认情况下，发送和接收数据都是阻塞的，直到另一方准备好
6.貌似Go中我们不可以自己管理线程, 咋利用多核?
Buffered Channels
1.通道声明时可以设置make第二个参数为通道的buffer: c := make(chan int, 2)
2.一直向通道中发送内容，直接达到通道设置的buffer数
3.从通道接收内容，直接通道中内容为空
4.看一个死锁的例子:   ch := makee(chan int, 1)
                      ch <- 1
                      ch <- 2
                      *.此时1等待被接收，所以一直在这阻断着，而2等待着发往ch,但因为没有变量接收1，所以就卡死在这了，解决方法是将make中的缓冲参数改为2
Range and Close
1.当通道中没有数据以后要将使用close()函数将通道关闭: close(channel)
2.只有sender可以关闭通道，receiver不可以
3.receiver可以使用"v,ok := <-ch"形式，通过ok的值是true还是false判断通道是否关闭
4.可以使用"for i := range c"的形式来连续的从通道接收值
5.不向向已关闭的通道(after close(channel))发送数据 //这个是重点，实际测试会出现死锁，因为一方channel等待接收数据，另一方没有数据，就这样一直耗着.其实还没有太理解
6.平时不要使用close()函数关闭通道，只有当sender没数据了需要告诉receiver的时候才能调用,如告诉for i := range c已没数据了，从而终止/完成循环的执行
Select
1.select语句块有多个case,多个case同时对每个case中的channel进行监听，哪个先进来则执行哪个case下的语句, 如果线程执行到该协程中时有多个case中的channel都满足条件了则会随机选择一个满足条件的case执行相应的语句 //需要注意的是这里为什么c通道执行完成后不用执行close()函数
2.注意for{select{}}的连用，注意到select有一个case的语句中有return语句，所以猜测这个return语句退出了函数的执行，所以说不会出现通道的读取情况了，因此省略了close()语句
Default Selection
1.这个简单，类似于switch中的default,即其它语句都不满足的情况下执行default下的语句，具体执行是每次线程执行到该协程时如果如果其它case都不满足的话都会执行一遍default下的语句  // 大机制上来说，select本就类似于多条件分支语句switch
2.time.Tick()
3.time.After()
Exercise: Equivalent Binary Trees
Exercise: Equivalent Binary Trees
sync.Mutex
1.讲的是sync包中的Mutex模块这里面有两个方法Lock和Unlock，用来处理sync问题
2. Inc和Value方法
3. defer
Exercise: Web Crawler
===================================
Go中常用的包: fmt,os,net
Stringer是fmt包中声明的接口,内定义了方法String()
Error是内建的接口,内定义了方法Error()
使用print,println等打印值时会调用Stringer中的String()方法，当打印时检测到类型为error时，会调用内建接口Error的Error()方法
文档中每个包都有几个例子，学一个包一开始，先从这些例子开始应该是个好方法
