以下内容均是从golang官方提供的入门教程中总结的: https://tour.golang.org/welcome/1
Packages
1.每个Go程序都是由包(s)组成的
2.Go程序从main包(的main函数)开始运行
3.使用import关键字导入包
4.包名和导入路径的最后一个元素名称相同
*.从当前看，包就是一个文件夹，里面有好多文件，并且这些文件的第一个有效行都是"package 包名"
*.import关键字导入包名应该隐式的以Go安装路径下的src文件夹为默认搜索路径，这个是我猜的，但应该没问题，因为从导入的包名看"fmt", "math/rand", fmt是src下的文件夹， math是src下的文件夹，rand是math下的文件夹，所以说拿安装路径下的src文件夹作为基路径或说搜索路径应该没啥问题
Imports
1.在使用import关键字导入包时，可以使用多个import，每个import后跟一个包名，也可以使用一个import，将所有要导入的包都放在括号里。官方推荐使用第二种方法，官方叫它"因式分解法"
*.pa+pb+pc=p(a+b+c)

  import "fmt"
  import "math"

  import ("fmt";"math")
  import (
          "fmt"
          "math"
  )  //通过最后两个import判断"因式分解法"中多个包的分隔符为";"或"\n"
*.上面星号的最后一个import的写法是官方的写法，倒数第二个如果多个包写在一行要用分号隔开

Exported names
1.使用import将包导入进来以后，程序只能引用包中以大写字母开头的定义，可以理解为当执行import的时候会将相应包中以大写字母开头的定义给导进当前程序的空间，而那些以非大写字母开头的定义仅仅可以在包内部引用，官方将这些以大写字母开头的叫做"exported name",从字面意思上理解是"导出的名称",此时这个"导出"的动作应该是看作在执行"import 包名"的时候，会将包里以大写字母开头的定义从"包"里导出到程序的应用空间中。这么解释可能不太对，但目前这么解释的话是有帮助理解的。
2.一个包里可包含多个扩展名为go的文件，而在import的时候应该是将包里所有文件中的以大写字母开头的定义都导到程序空间中了。这个也是猜的，不过通过Packages那一节的例子中的math.Int //到这断了，应该是误删了，后面应该是 "这个例子可以推断出来"
Functions
1.函数可以带任意多个参数，包含0个
2.函数参数中，形参类型出现在形参的后面
3.函数基本语法func func_name(arg1 type1, arg2 type2) return_type { statements }  //这块要注意函数如果有形参,则形参的类型一定不能少,即func f(a)是错误的,要写成func f(a type).
Functions continued
1.当函数中连续的参数类型相同时，可以简写，只保存最后一个参数的类型
*. x int, y int   ->  x,y int
Multiple results
1.如果返回多个结果可以设置多个返回值的类型，多个类型使用圆括号括起来，位置在包含函数参数的圆括号后面
2.如果函数有多个返回值，则可以直接使用返回结果进行分解赋值
Named return value
1.函数返回值也可以被命名，就是函数定义中返回类型的位置，之前讲返回多个值的时候该位置是括号里放上返回类型，现在只是在返回类型前再加上变量名，作为返回的变量；如果要返回这种带有名称的返回值时，return语句后不接任何参数(这次看又发现了问题，return是不用加参数，但函数体中的变量名必须用函数声明时在返回值类型中所定义的变量，感觉这种情况只是在编译阶段编译器自动将返回值类型中定义的名称给加到函数中了，因为函数变量的赋值要不使用关键字var,要不使用海象赋值符:=,但给定的例子中直接使用的等号=进行赋值，就说明编译器在执行到x,y赋值之有就已经声明了，而这个声明应该是编译器阶段做的)。
2.需要注意的是这种形式最好只在较短的函数中用，如果函数较长的话用这种形式会损失程序可读性。
3.带名称的返回值在命名时最好是有意义的，即根据返回值名称即可知道返回的大概是什么东西
Variables
1.使用var来定义单个变量或是多个变量，变量的形式和函数参数中的形式差不多
*. var a int
   var a,b,c int
2.var关键字可以用在包级别，也可用在函数级别，说白了就是既可在函数里面使用var定义变量，也可在函数外面使用var定义变量。可能不准确但就目前看到的可以先这样讲
Variables with initializers
1.声明变量时可以包含初始化器，一个变量一个；所谓的初始化说中了就是变量赋值，这句话说白了就是声明变量时可以给变量赋值，一个变量一个值，这样更明了一些
*.var i, j int = 1, 2
2.如果声明变量时有初始化器，则变量后面的类型可以忽略，程序会将初始化器的类型作为变量的类型。换句话说就是声明变量时可以不指明变量类型，程序会将变量值的类型作为变量的类型
Short variable declarations
1.变量声明不仅可以通过var关键字，还可以使用:=符号，使用这种形式不需要var关键字，而且也不用显示的给出变量类型。但是:=和var有一点不同的是，var既可用在包级别又可用在函数级别，而:=只可用在函数级别
2.对照1来看，包级别的语句都需要以关键字打头
3.既然:=不需要显示给出变量类型，则肯定是用到推断功能了(infer)
Basic types
1.Go中的基本类型有:
布尔型: bool
字符串: string
整型: int int8 int16 int32 int64
无符号整型: uint uint8 uint16 uint32 uint64 uintptr          //int uint unitptr默认是自适应的,即虽然看起来int有好几种,unit也有好好种,但如果你是在32位系统上运行则,编译器会动将int精确为int32,也就是说我们用的时候只需要使用int和uint就行,不用人为的去写后面的位数; 但是如果你明确知道你想存储的是16位的,则你就用int16,这样即使你在32或64位系统上运行,用的也是int16,这样可以减少内存的占用. 至于uintptr还不会用,它的作用见:https://stackoverflow.com/questions/59042646/whats-the-difference-between-uint-and-uintptr-in-golang
字节型: byte  //unit8的别名
文字型: rune  //int32的别名，表示一个Unicode码点
符点型: float32 float64    //int 和float的最大值最小值在src/math/const.go中都有说明,也备注了算法,也可以直接使用math.MaxInt32等这样的形式直接输出
复合型: complex64 complex128   //complex64用来描述float32类型的实数和虚数,complex128用来描述float64类型的实数和虚数,详述:https://www.cloudhadoop.com/2018/12/golang-tutorials-complex-types-numbers.html
2.变量的声明也可以使用"因式分解"式，即使用一个var关键字完成多个变量的声明
3.int,uint和uintptr这三个类型在32位系统中它们的位宽是32位，在64位系统下它们的位宽是64位
4.对于整型一般就用int,除非定义时知道数值的大小int可能不够再去考虑其它整型(废话)  //这不是废话,上面在"无符号整型"后的备注中提到了,我们写的是int,但实际执行的时候,编译器是会根据程序所在系统的位数去相应的分配空间,而这句话存在的意义我能想到的一种情景是: 假设我们用的系统是32位的系统,如果直接使用int的话,编译器预处理替换为int32,但是我们想要存的数要比int32大,此时我们就可以显式的指定数值类型为int64,此时编译器在处理这块的时候,因为我们已经明明确说明了这是一个要用int64才能装下的数,就不会去考虑当前系统是32位的事儿了.
Zero values
1.当声明变量时，如果没有设置初始化器，则变量会默认赋一个该变量所属类型的零值:
  数值类型: 0
  布尔型: false
  字符串: ""
Type conversions
1.Go中的类型转换必须要精确指定要转换到的类型
，表现在实际的写法上即要将被转换值作为相应类型的参数
  var i int = 42
  var f float64 = float64(i)
  var u uint = uint(f)
  还可以使用:=形式:
    i := 42
    f := float64(i)
    u := uint(f)        //对于数值和字符串相转换,如var a int = 97 , var b string = string(a) 这种写法得到的b是ascii码,小写字母"a",而不是我们想要的"97", 想要得到"97"要使用strconv包的Itoa函数, var b string = strconv.Itoa(a), 得到b为"97" (https://yourbasic.org/golang/convert-int-to-string/)
2.C语言中的类型转换不强制要求加上被转换到的类型(C都忘了...)
Type inference
1.到目前为止变量声明的几种形式:
  var a int  //默认会为a赋值0
  var a int = 1  //带有初始化器的形式
  var a = 1   //有初始化器时变量类型可省，自动根据初始化器进行推断
  var a, b int  //同时声明多个类型相同的变量
  var a,b int = 1, 2  //同时声明多个类型相同的变量且带有初始化器的
  var a,b = 1, 2  //同时声明多个类型相同的变量，且带有初始化器，此时变量的类型可忽略，会自动初始化器进行判断
  a := 3  //:=这种赋值形式本来对类型就是隐式的需要根据值进行判断，并且不需要关键字var;但只能用于函数级别
2.如果之前定义了变量i, var i int,则将i作为一个新变量的值时，j := i , 新变量的类型和i的类型相同
3.如果使用:=声明的变量类型为数值型常量时，该变量的类型要看数值的精度，从而确定是int, float64, complex128还是...
Constants
1.常量声明使用关键字const
2.常量值可以是字符，字符串，布尔值或是数值
3.常量不能使用:=语法声明
4.这个是自己猜的，常量定义时就必须赋值，否则会出错，程序不会给默认值  //仔细想想这么做也是有道理的，常量代表固定值，或说后期不可改的值，即然这样，你声明常量时如果不初始化，让编译器给个zero value就没啥意义了，所以干脆就设计成常量声量时必须有值，没值编译不过.
Numeric Constants
1.常量声明也可使用因式分解法"factored"
2.一个未明确写明类型的常量具体的类型要根据右边的值来确定
3.位运算符: & | ^ << >>   &:都有1才是1; |:有一个是1就是1; ^:有且只有一边是1才是1; <<:左移变大; >>:右移变小  //该教程中举的例子很好:https://www.tutorialspoint.com/go/go_bitwise_operators.htm
For
1.Go中只有一种循环结构，for循环
2.for循环的基本结构为for关键字，然后是由两个分号分隔的三部分，接着是由一对花括号将要执行的语句括起来。需要注意的是由分号分隔的那三部分不需要使用圆括号括起来
3.init部分的变量声明仅在该for循环中有效
*.这个for的每一部分就不具体说了，基本上和其它语言的for循环没区别
For continued
1.这个是接上一节的For讲的，主要说的是由分号分隔的那三部分中的第一部分init和第三部分post都是可选的，即如果不写也是正确的。其实如果省略第一和第三部分，则一般情况下，第一部分会从包级别中去获取，第三部分会在for循环语句中获取，总的来说还是完整的，只是位置不一样罢了
2.虽然省略了第一和第三部分，但是那两个分号还是结构中必须有的
*.抓住for循环的本质，有初始点，有判断条件，有结束点
For is Go's "while"
1.上面一节还说了如果省略了初始化部分和post部分但两个分号还是必须有的，这节就打脸了，即使省略了第一三部分，两个分号也可省略，这样写下来看起来就像其它语言中的while循环了，但还是那句话，虽说省略，但那三个基本点肯定在上下文都 是可以找到的
  *. func main() {
         sum := 1  //这部分相当于init
         for sum < 1000 {
             sum += sum  //这部分充当了post
         }
     }
Forever
1.这节还是继续对for结构由分号分隔的三部分做说明，这次是条件部分也可省略，如果这部分省略，如果在执行语句中没有设定退出条件，则会永远的执行下去，话又说回来了，如果在执行语句中设定退出条件，这不是又是换汤不换药嘛，只不过相应的元素没有位于由分号分隔的位置；抓本质！
  func main() {
    sum := 1
    for{
      if sum < 1000{
        fmt.Println(sum)
        sum ++
      } else {
        break
      }
    }
  }     //上面的语句中随然for循环部分啥都没有,但其实三要素都在,initializer为sum:=1,条件部分为if{}else{},第三部分为sum++; 其实大家都在
If
1.Go中最基本的if语句也是if引导，后面跟条件表达式，注意这块和for相似，条件部分不需要使用圆括号括起(对于for是由两个分号隔开的三部分不需要使用圆括号括起，但是无论是if还是for那个位置都是一样的，都是位于关键字后，起始花括号前)；然后后面就是跟着由一对花括号括括起来的执行语句
If with a short statement
1.这节讲的if的特性目前接触的其它语言里没有，或是没有见过，就是在if的条件表达式前加一个语句，类似于for中的init部分，仅仅在最开始时执行一次
2.if中的init部分和条件表达式部分也是使用分号隔开
3.if语句中的init部分声明的变量的作用范围为它所在的if语句，生命周期为if语句执行结束
*. if v := math.Pow(x, n); v < lim {
      return v
   }
If and else
1.if语句中最最常用的还有一个else关键字,这节主要讲的是if结构中init如果定义了变量，则不仅在if的语句块中有效，在相应的else语句块中也有效
*.if v := math.Pow(x,n); v < lim {
    return v
  } else {
      fmt.Printf("%g >= %g\n", v, lim)
    }
Exercise: Loops and Functions
1.这个练习本节最后再做，先将基础概念整完
Switch
1.Switch语句其实是if...else...的更短的一种书写形式，但if...else...过多的时候使用switch语句可读性会好一些; switch同if一样,也可以有initializer部分,同条件部分用分号隔开,当然也可以省略initializer部分,具体用不用根据实际情况去定; 使用switch时,当所有条件都不满足时,执行的是default关键字下的语句,这点要注意.
2.在像C等一些语言中也有swtich语句，在这些语句中，每个case下的执行语句都要有一个break来跳过继续对下面case检测执行。但在Go中不需要在每条case下的执行语句中都加上break语句，实际上是Go已经为我们考虑好了，那个break是程序执行时自动加上去的，不用我们干预，本质上来说还是有的
3.Go中case后面的类型不限于变量，且相应case部分也不一定要是整数. 从官文给出的例子来看,常见的形式有三种: 
    switch下是变量名,case下是变量名所匹配的值;  switch var {case 1: xxx; case 2: xxx; default: xxx}  //为了写在一行,不同case用分号隔开,但实际能否这样用还没试过
    switch下有初始值;以及用来匹配case的变量;  switch var := expression; var {case 1: xxx; case 2: xxx; default: xxx}
    switch下是空,case下是值为true或false的逻辑表达式; switch {case a>b: xxx; case a<b: xxx; default: xxx}
*.switch主要用于替代较长的if...else...
Switch evaluation order
1.这节主要讲的是如果switch要有多个case时，这些case的评估顺序是啥样的，这个其实都知道，是从上向下的，并且一旦遇到哪个case后面的值匹配成功了，则执行完相应case下面的语句后就不再继续向下匹配其它的case后面的值了，因为之前也说过,Go自动为每个case下面的执行语句的最后面加了break来跳出switch
Switch with no condition
1.当switch中无条件表达式时，条件表达式相当于true
2.其实又回到要理解问题的本质上来了，其实所谓的无所件，只是条件部分不在switch的条件表达式部分了，而是转移到每个case值上，万变不离其宗
*.当switch无条件时，主要是处理较长的if...then...else...
*.switch {
        case t.Hour() < 12:
          fmt.Println("Good morning!")
        case t.Hour() < 17:
          fmt.Println("Good afternoon!")
        default:
          fmt.Println("Good evening.")
   }
Defer
1.函数前面如果加上defer关键字的话，如果该函数在另外一个函数里面时，在执行到带有defer前缀的函数时，仅仅会将该函数进行预处理，即将变量换成值这类的操作，但并不会立刻执行，直到这个函数的外层函数执行完毕后，才会执行该函数
Stacking defers
1.如果函数中存在多个defer时，则这多个带有defer的函数会被入栈，栈的原理是后进先出，所以在相应的外层函数执行完后，里面带有derer的函数是被从后向前执行的
Pointers
1.Go语言也支持指针，经常在C和C++上听说指针
2.Go中的指针比较简单只有一种声明形式，不支持运算
  *T:  var p *int  //声明一个指针p,p中存的是地址，该地址指向的内存区域存的是int型值(话说内存地址有类型吗?查了一下好像是有,是无符号整型,表示数据存储在内存中的起始位置)
3.给指针变量赋值的一般形式是: 地址符&加上变量名
  i := 42  p = &i
4.指针变量前加上*表示的是该指针变量指向内存区域的值
  *p = 21  //指针变量存放的实际是内存地址,就该例来说p存放的实际上是在内存中为变量i分配的地址；而加上*之后，*p表示的是指针变量p的值(变量i的内存地址)指向的值)
  *.指针其实很简单，只是比普通的变量多一层而已，我觉得越说多越乱，先这样吧
Structs
1.tutorial中讲的是struct(结构体)是一个字段的集合，这个可以理解，在C中看过对struct类型的描述，C中其实也是一堆字段的集合，而且这些字段的类型可以是任意的,就目前可以简单的理解成struct体中是一堆没有initializer的变量声明(可能不准确，但目前看是这样子的)
Struct Fields
1.对struct中的field(字段，成员)的访问，是通过点符号(".")实现的
  type Vertex struct {
       X int
       Y int
  }
  func main() {
    v := Vertex{1, 2}
    v.X = 4
    fmt.Println(v.X)
  }
*.不同语言中对于同一概念的翻译可能不同，主要的还是明白本质意思
Pointers to structs
1.还可以通过struct pointer(结构体指针)来访问struct fields(结构体的字段或叫成员)
2.当p的类型为struct pointer时，正常情况下应该使用(*p).X才能够访问结构体中的field X,但是Go语言允许我们在不明确表示废弃*前缀的情况下直接使用p.X的方式来访问结构体中的X field(好多初学者其实对于一些概念的描述可能会很迷糊，因为以前没接触过，脑子里没有可供参考的东西，我当时也是，现在再回头看，就要简单的多；比如这点开头说的p的类型为结构体指针，其实要明白，其实说的就是p中存放的值指向的内存地址处存放的数据其类型为结构体，而给结构体指针p前加上*号前缀就表示该结构体内容本身了.举例来说,有10个抽屉,相当于内存中的地址,我将一把锁放在了第3个抽屉,那么 假设声明了var p *锁,则p的值就是3, *p就是那把锁)
3.struct value加上&符号，返回的是一个指向struct value的指针(这句话听起来也别扭，首先struct value是个什么东西？(从例子上看其实就是类似于类的实例，这么说不准确，准确来说应该就是类的实例，因为结构体也是一种类型，所谓类型就是类，所以说struct value其实就是类的实例)也不好描述，看例子吧: p=&Vertex{1,2} 这个例子中，Vertex{1,2}相当于描述中讲的struct value; 此时p是一个指针变量，也就是说p中存放的是Vertex{1,2}这个实例在内存中被分配的地址，然后上一节也说了按理说如果要引用Vertex中的值的话，需要用(*p).X/Y,但是Go语言在这块为我们做了处理，即p的*前缀可以省略掉)
Struct Literals
1.struct literal,看完例子感觉,所谓的Struct Literals是指通过给结构体类型中字段赋值的方式来得到stucture value,也就是说可以将Structure Literal理解为一种得到structrue value的手段.而学到的新东西是在实例化化的时候，结构体中的所有字段不必完全都赋到值，可以只赋一部分，剩余那部分没赋到的，会根据之前讲过的，按相应类型的"零值"去赋(整型的是0,字符串类型的是""等等吧,这个也有一部分是自己猜的，不过应该没啥大问题),下面是官文中给的例子:
   type Vertex struct { X, Y int }
    var (
    	v1 = Vertex{1, 2}  // has type Vertex
    	v2 = Vertex{X: 1}  // Y:0 is implicit
    	v3 = Vertex{}      // X:0 and Y:0
    	p  = &Vertex{1, 2} // has type *Vertex
    )
    *.这是该小节的第一句话, A struct literal denotes a newly allocated struct value by listing the values of its fields. 其中newly翻译为"重新"而不是"最近",listing翻译为"登记"而不是"列出",整个句子的意思应该更好理解一些
2.我感觉把Struct Literal叫做结构体的实例化方法或叫创建结构体的对象的方法比较合适(根据给出的例子推想出来的)
Arrays
1.数组类型的声明: [n]T   //一个含有n个类型为T的数组(声明一个数组，该数组有n个类型为T的元素)
  var a [2]string  //定义一个含有2个类型为string的数组a(声明一个数组a,该数组中有2个类型为string的元素)
2.数组的引用和赋值与其它语言一样，都是使用角标的形式
  a[0] = "Hello"
  a[1] = "World"
3.声明数组时如果限定了长度，则以后使用该数组时，长度就是固定的了，不可以对数组的长度进行重定义;但最后一句话不是很明白:This seems limiting, but don't worry; Go provides a convenient way of working with arrays.它说的意思是明白，前面说了声明时带有长度的数组后期不可改变大小，但又说这种限制不用担心，Go为我们提供了一种方便的方式来使用数组，这句话指的是什么?指的是后面要说到了声明时可以不定义长度的形式吗?
4.声明数组时赋值(或者叫声明一个带有初始化器的数组?) [n]T{value1, value2, ...}
  var primes := [6]int{2, 3, 5, 7, 11, 13}  //这里看出错误了，因为这里的声明用的是短形式:=,所以说打头的关键字var是没有必要的，看了一眼原文也是这样，先不去var,暂且留在这里吧
5.总结一下数组的声明赋值常用方法:
  a := [2]int{1,2} //短形式的海象符必须在声明时就赋值
  var a [2]int   a[0]=1  a[1]=2  //使用var可以先声明,后面使用索引的方式赋值
  var a [2]int = [2]int{1,2}  //使用var同样可以连声明和赋值在一块做了
  var a = [2]int{1,2} //使用var可以省略左边声明部分的显式类型说明,因为可以根据右边推断出来
Slices
1.首先说了array的大小是固定的。接着引出相对而言slice是变化的，slice在其它语言中经常翻译为分片，通过看他的描述，在Go里对slice翻译为分片也是合适的。而分片其实指的是取array的一部分，也就是说slice一般是和array联用;
2.slice也有类型，为[]T,即未指定大小，[]中未指定分片的大小，也就是说大小是动态的，T一般为相应array的类型;
3.分片通常的用法是先声明一个数组，然后通过指定数组的上限和下限来为slice赋值
  *. primes := [6]int{2, 3, 5, 7, 11, 13}
     var s []int = primes[1:4]   //这里面的[]int是可以省略的，也可写作:
     s := primes[1:4]
4.接着3说，数组的分片一般是包前不包后的，即a[1,4]是指数组a中第1到第3个元素
*.第三条的例子，可以看出分片s的类型是[]T,这个现在就死记吧，数组的分片(感觉叫切片更生动一些)(不知道将slice和array连起来说准不准确，暂且先这样记吧)，一开始我以为[]T只是因为方便不用刻意的去关心分片的大小，事实上Go可能也是这样考虑的；我尝试着将分片s的类型换成[3]int,因为后面的分片就三个元素嘛，但是执行失败了。而且回显明确告诉我分片的类型是[]T(不能指定slice包含元素的数量)
Slices are like references to arrays
1.slice不存储任何数据，对slice中任意元素的更改其实是直接改变该slice相应的underlying array.举例来说 underlying array为base=[1,2,3,4,5,6,7,8,9,10]这10个数，然后我对该underlying array做了一个切片，比如slice:=base[0:5],我们都知道变量声明完之后其实是在内存中分配了一片空间，然后使用变量时，其实是利用变量的地址准确的找到变量数据在内存中的位置(大概是这样，具体的也记不清了)，再说这里的分片，其实也是内存中的一段地址，特殊的是这个地址是在underlying array的范围内取，这样一来，其实对分片数据的更改，就直接作用到underlying array中的数据。一开始我想用array的别名来描述slice,但是这样不准确，因为别名是对underlying array的完全引用而slice可以是整个基础数组也可能是基础数组的一部分,所以不能把slice理解成其underlying array的别名(这段的描述有点屎了)
2.既然slice会直接改变它underlying array中的数据，则其它的slice肯定也会受到影响
Slice literals
1.前面有个struct literal从例子中看，struct literal就是一个创建结构体实例或是对象的方法或叫手段,即通过给结构体中字段进行赋值的方法来得到struture value(也就是所谓的结构体实例或对象)
2.对slice literal官方tour给的描述是:"a slice就像是一个没有长度的array literal"，
其实不是很理解，暂且将slice literal的结构定义为 "[]T{v1,v2,...,vn}"
3.声明一个array literal: [3]bool{true, true, false}
4.声明一个slice literal: []bool{true, true, false}
*.其中3和4的区别是，3只是简单的声明一个含有三个为bool类型的array并赋值；而4其实可以理解为2步，第一步是创建一个array第二步是基于第一步的array创建一个slice
5.对于元素类型为结构体的slice,在声明时初始化需要注意的是,不能和单个结构体初始化一样,只给部分filed赋值,剩下的field自动获得相应类型的初始值; 必须要将结构体中所有的field都赋值,否则会报错.
  s := []struct {
    i int
    b bool
  }{
    {2, true}
    {3, false}
    {5, true}
    {7, true}
    {11, false}
    {13, true}
  }
6.总结一下：所谓的slice literal就是数组的声明与分片的声明合成一个了(先这样理解吧) //或者参照structure literal,slice literal就是使用[]T{x,...}的方式得到slice的一种方法
7.再多说一句，从之前的struct literal,到array literal, 再到slice literal,其实头两个基本上就是之前讲的变量声明的时候就顺带赋值了，而slice literal虽说也是声明的时候就赋值了，但是不要忘了，slice是要基于array的，这句话是关键。所以再理解slice literal的时候就要分两步理解，第一步是array的创建，第二步是slice的build(叫构建，生成啥的，随便叫吧)
8.slice也是有类型的，它的类型是"没有长度的数组类型" []T
9.再说一下slice literal的定义：slice literal就像是一个没有长度的array literal
Slice defaults
1.如果slice的low bound和或high bound省略的话，则默认会用它们的默认值替代，即，如果low bound省略则用0替代;如果high bound省略的话，则用len(array)替代
    var a [10]int
    a[0:10]
    a[:10]  //low bound default to 0
    a[0:]  // high bound default to 10
    a[:]  //low bound default to 0 and high 10
2.看这节例子结果的时候我其实一开始有点理解跑偏了，我把所有的操作都和数组联系起来，其实不是的:
s := []int{2, 3, 5, 7, 11, 13}  //这个s是对右侧无名数组的一个分片
s = s[1:4]  //这个是从上面那句得到的s中取第1，2，3个元素(3,5,7)
s = s[:2]   //这个是在上面那句s的结果取第0和第1个值(3，5)
s = s[1:]   //这个是在上面那句的s的结果取第1个值(5)
*.上面几节也说过slice其实是对array的引用，我理解slice其实存的是地址，而不是值，对slice[1]的修改，其实是对在slice[1]中存储的地址所指向的数据进行修改，所以才会有之前说的对一个slice的修改，可能会影响到其它的slice,如果它们有相同引用的话
*.上面那4个s,第2，3，4分别是以上一句为源进行截取，但是下一节会讲到，它们是可扩展的，如果扩展的话，2，3，4中每一个的high bound最大都可以到6,len({2,3,5,7,11,13})，因为它们本质上还是在那个无名数组的范围内操作
Slice length and capacity
1.每个slice都有两个属性，一个叫length,一个叫capacity.
  length的值为当前slice中含有的元素的个数
  capacity的值为当前slice所基于的那个array的长度减去当前slice的low bound
2.可以通过len(s)来得到分片s的length属性值
  可以通过cap(s)来得到分片s的cap(s)属性值   //看到这明白了goroutines 有一节的代码中的cap()函数是啥意思了
  *.len(s)理解为当前slice的长度; cap(s)理解为当前slice可能的最大长度
  *.len()函数没啥说的，好理解; 而cap()函数我觉得应该理解为:"左值不动, 只能右值向右扩展"，此时再去理解cap()的值是len(array)-slice(low bound)就通了
3.capacity其实可以理解为当前分片最多可以拥有的元素个数，这个个数不要和当前分片的长度相混淆，当前分片的长度指的是当前分片已有元素的个数，而当前分片最多可以拥有元素的个数倾向于分片的扩展性，而这个扩展性也是基于那个最基础的array,因为对于一个分片来说，你再怎么折腾也是在你所基于的那个array所拥有的范围内活动。所以正常情况下可以理解为capacity的值就是其所基于的那个array中元素的个数，但这样说还不对，因为概念中明确强调了，是从low bound这个数值开始，所以capacity的值是len(array)-low bound
4.可以随时扩展分片的high bound,但是不能超过len(array),否则会报"slice bounds out of range"的错误
*.再次强调，分片中存放的应该是基础array中元素的地址，所以分片的活动范围最大就是array所表达的那个范围
*.这一节看的其实还是有点小纠结的，因为涉及到了对分片进行分片，其实只要抓住本质一切都很明朗
*.这一块要多看，多理解理解
Nil slices
1.之前讲过如果变量声明的时候如果没有初始化器，也就是说如果声明时不赋值，则Go会按类型给相应的变量赋一个值，这个值Go叫它zero value,也就是零值。不管叫啥明白这个意思就好。同样的slice如果声明时不赋值也会默认有一个zero value,为nil.
2.从例子来看，所谓slice声明时不赋值，指的是没有右边的数组那部分，var s []int,这样的slice,它的len()和cap()都是0，因为这个slice没有underlying array(这个词我还是觉得翻译为基础数组好一些)
3.一般是用if语句去判断slice是否未初始化.这块就要注意了, "var a []int" 和 "var a = []int{}" 是不一样的,前者是没有初始化,此时a值为nil,而后者的值不是nil, 另外通过实践还从编译器得到一名话,"slice can only be compared to nil",即在使用if语句判断的时候,条件部分的"=="号一边是slice名称,另一边只能是nil.//得到提示使用的例子为:var x []int = []int{} if x==[]int{}{ fmt.Println("nil!")}
Creating a slice with make
1.首先Go提供了一个内建的函数,make,它的返回值就是一个slice；文中还有一句"this is how you create dynamically-sized arrays"也就是make是用来创建动态数组的方式，记得其它语言中当数据的类型为[]T时声明的就是动态数组，但是在Go中，[]T只是slice的类型，数组array的类型必须是[n]T即必须指定大小。还接着上面那句英文，感觉给的例子不是创建的动态数组呀，"a := make([]int, 5)"还是指定了数组的大小了，哎，这块有点不明所以。 //现在感觉呀,golang中所谓的动态数组和C中的还不太一样, golang中的动态数组的动态是有一个大前提的,即在underlying array下的动态, 这么想应该就通了
2.内建函数make的参数可以是两个，也可以是三个，但是第一个一般都是slice的类型:
   两个参数 make([]T, slice_len)
   三个参数 make([]T, slice_len, slice_caps)
   *.两个参数的make逻辑: 先根据[]T中的T和slice_len生成一个无名的数组，并且给该数组赋slice_len个0,此时数组生成了，再根据[]T来生成slice并返回(感觉如果没有caps参数的话，默认caps的值等于len的值)
   *.三个参数的make逻辑: 先根据slice_caps确定无名数组的长度，然后根据[]T和slice_len创建slice并确定slice的元素个数(说白了就是slice中有几个0)
   *.上面这两条完全是猜测，待后期接触了关于make的api说明再好好理解一翻
   *.刚又悟出了两点: 
         1.两个参数时，省略的第三个参数值和第二个值相同；且第三个参数值表示的是underylying array的长度，第二个参数表示的是slice的长度;
         2.三个参数可以参照两个参数，第三个参数为underylying array的长度，第二个参数为slice的长度
3.到现在是看出来了，分片的可伸缩性，只要是在underlying array所表达的范围内可以随便折腾; 还有一点需要注意,make函数中,第三个参数slice_caps一定是大于等于第二个参数slice_len的.
4.再通过例子来了解一下make两个参数和三个参数:
    a = make([]int, 6)  此时虽说是两个参数,但是预处理的时候第三个参数同第3个,即,在执行前原表达式会被改为: a = make([]int,6,6),然后先根据第三个参数创建一个无名数组,这个无名数组有6个0,然后根据第一,二个参数,确定slice的大小 a := [8个0][0:6].此时根据上面的算法,len(a)值为6,cap(a)的值为8-0=8.
    a = make([]int,6,8),有了上面2个参数的,3个参数的也就不用说了
Slices of slices
1.叫slices of slices，其实就像c或java中的多维数组，使用方法一模一样，都是通过多维索引，看第一眼的时候觉得会难一些，其实不然。
  board := [][]string{
      []string{"-", "-", "-"}
      []string{"-", "-", "-"}
      []string{"-", "-", "-"}
  }
2.strings包里的Join()函数可以将slice或是array中的字符串进行拼接并输出
Appending to a slice
1.这个很好理解，和python的列表追加函数是一个意思，但是用法不一样；
2.append函数的定义: func append(s []T, vs...T) []T
3.append函数的实际用法: s = append(s,1)  //其中s是slice;可同时追加多个值
4.当追加的元素个数超过了slice当前可以包含的最大个数cap(slice)时，Go会给slice重新分配一个array,并且将返回的slice指向这个新的underlying array(这个应该就是原先那块地不够存了，然后根据返回的slice的长度重新找一块地存储它，并且将slice指向新的array,也就是说如果返回后的slice的长度如果超过了当的undelying array的长度后，slice append之前的&slice[0]和slice append之后的&slice[0]已经不是一个值了):
    func main() {
    	age := [3]int{1,2,3}
    	fmt.Println(&age[0]) //原始数组第一个元素的地址
    
    	sli := age[0:1]  //原始sli,里面只有一个元素len(sli)=1,cap(sli)=3
    	fmt.Println(&sli[0]) //因为sli的len,还未超过基础数组的大小,所以输出值同上
    
    	sli = append(sli,4) //向sli追加1个元素,此时len(sli)=2,cap(sli)=3
    	fmt.Println(&sli[0])//因为sli的len,还未超过基础数组的大小,所以输出值同上
    
    	sli = append(sli,4) //向sli追加1个元素,此时len(sli)=3,cap(sli)=3
    	fmt.Println(&sli[0])//因为sli的len,还未超过基础数组的大小,所以输出值同上
    
    	sli = append(sli,4) //向sli追加1个元素,此时len(sli)=4,cap(sli)这个大小目前还不知道,因为不清楚,重新分配后的基础数组在原数组的大小上做加法运算的规则
    	fmt.Println(&sli[0]) //此时因为len(sli)已超过了3,所以重新分配了基础数组的位置,而sli又是对基础数组地址的引用,因此此处的第0个元素和上面不同了
    	fmt.Println(&age[0])
    	fmt.Println(age)
    	fmt.Println(sli)
    }
Range
1.for循环中的range形式用于遍历一个slice或是一个map
2.当使用range遍历一个slice的时候，每次遍历会返回两个值，index和与之对应的value(文中特别强调那个值是slice相应位置的一个copy,说白了就是告诉我们，对slice的遍历并不会影响原slice的内容，即并不是说将0位置的索引值返回后，这个值就从原slice删除了.这一点可以和python中使用readline()或readlines()函数从文件对象中读行形成鲜明对比,如readline()函数是调一次文件对象中就少一个元素,而readlines()调一次文件对象直接就空了)
3.for循环中对slice使用range的形式: for i, v := range slice { statements}  //需要注意的是在for和range联用时,不能将i,v:=range slice看成是上面讲for循环三个部分的第一部分,而是这样就够了,如果你强行加上i,v:range slice;condition;x++|x--是会报错的,具体后面还要看一下for和range联用的语法中有没有写其它的.
*.for循环中对map的遍历还没说，因为还没看到map,后面应该有相关的例子,到时再补
Range continued
1.刚才说过for循环中的range slice形式，会返回两个值，一个是index,还有一个是和index相对应的值;如果我们只想要index,则可以将value的位置替换为_,反之，如果只想要value,则可以使用_代替index:
  for i, _ := range slice
  for _, value := range slice
2.如果只想要index值，可以直接将",value"直接省略,即:
  for i := range slice
Exercise: Slices
1.练习部分，下一遍再看吧
Maps
1.map是由多个键值对组成，这个和其它语言中的字典，哈希啥的没区别
2.map使用的时候有以下几种情况:
 a.声明但未初始化的map,其值为nil,最关键的是未初始化的map不能被赋值:
    m := map[string]int
    m["age"] = 18     //上面这两句是不正确的写法,因为上句m声明时未被赋值,m的值为nil,此时不能直接给m赋值
   当m值为nil的时候,通常的用法和slice是一样的,即放在if语句中判断其值为nil:
    if m == nil { fmt.Println("nil!")}
 b.声明但未初始化的map,如果也想被赋值,其中一种方法是使用make方法返回一个同样类型的map对象:
    m := map[string]int
    m = make(map[string]int)
    m["age"] = 16   //经过上句make函数这么一折腾,此时的写法就是正确的,我经常忽略的一点就是第一句声明的时候m后的符号是海象符":=",第二句赋值时m后的是等号"=".
 c.可以直接使用make函数返回一个可被赋值的map对象
    m := make(map[string]int)
    m["age"] = 16  //此时的写法是正确的,因为make函数的参数为map类型时,返回的就是一个可直接操作的map.
 d.声明的时候直接将map进行初始化则后面可以直接给这个map赋值:
   *.声明的时候直接初始化,应该说的就是后面所说的map literal, 它是得到可操作map对象的一种手段.
    m := map[string]int{"zhangsan":19}
    m["liSi"] = 20  //这种写法是正确的,因为上句m在声明时赋了值,m的值不再是nil,故后面可以直接向m赋值
 e.还需要注意的就是当map的数据类型是稍复杂一点,如结构体的时候,初始化和后面赋值时的写法:
  type Vertex struct { Lat, Long float64 }
  初始化:
    var m = map[string]Vertex{
       "zhangsan":Vertex{80.6,-90.9},
       "lisi":Vertex{90.6,-80.9},
    }
  未初始化但使用make函数得到了可操作的map对象:
    var m map[string]Vertex
    m = make(map[string]Vertex)
    m["Bell Labs"] = Vertex{ 40.68433， -74.39967, }   //重要关注的是这句,即Vertex作为值时的写法
  同样,复杂的结构也可作为map中的键:
    type Vertex struct { X,Y int }
    var m  map[Vertex]int
    m = make(map[Vertex]int)   //上两句也可写为一句 m := make(map[Vertex]int) 或写为 m:= map[Vertx]int{Vertex{2,3}:4}
    m[Vertex{1,2}] = 3
    fmt.Println(m[Vertex{1,2}])  
Map literals
1.map literals指的同上边一样,即在声明时赋值从而得到相应的map对象.之前说的是上面讲的struct literals不同于其它的literals,当时的想法是看代码中先有type Vertex struct {X,Y int},然后下面才是var x := Vertex{1,2}就觉得struct literals和其它类型的literals不同了, 但其实是我想错了, 重要的一点是,所谓T literals的前提是你得先有T才行啊,你有了T下面才能谈T的literals,之前之所以理解错误,原因在于slice,array这些都是内置的类型,可以直接用,而Vertex是我们自定义的类型.
2.这一节的map literal看例子也是在声明时一并赋值，看一下例子中的部分代码:
  type Vertex struct {
    Lat, Long float64
  }
  
  var m = map[string]Vertex{
    "Bell Labs": Vertex{
      40.68433， -74.39967，
    },
    "Google": Vertex{
      37.42202, -122.08408,
    },
  }
Map literals continued
1.下面的例子是官文给的,map实例化的时候top-level type可省时的代码:
  type Vertex struct {
    Lat, Long float64
  }
  
  var m = map[string]Vertex{
    "Bell Labs": Vertex可写可不写{40.68433, -744.39967},   // "Bell Labs":[Vertex]{40.68433,-744.39967}本来想写这种形式,用[]表示是可选的,但[]在编程语言里又比较敏感怕引起混淆,所以干脆就用大白话表示了
    "Google": Vertex可写可不写{37.42202, -122.08408},
  }
*.这里其实主要就是搞不清楚top-level type是个啥玩意儿,一开始认为是在函数外声明的类型就是top-level type,因为go中没有类的概念,所以也谈不到在某个类内部声明.但是通过测试无论是在main函数里面还是外面声明Vertex,m在实例化的时候,相应键值中Vertex关键字都能省.所以之前想的肯定不对,结果上网上搜了搜,有个人还专门为弄不懂这个东西去开了个issue,后面他也是在stackoverflow上提问得到了相对满意的答案(另外该链接还给出了另一个字典值可省略类型名的情况,即在声明字典类型时,map[int]struct{x,y string},这样直接将类型声明嵌到另一个类型声明中,因为该struct结构体没名,故实例化的时候键值处直接{}即可),这个答案链接为: https://stackoverflow.com/questions/47579004/what-can-be-used-in-a-map-literal-instead-of-a-type-name-in-go  大概意思是:
基本上讲的是当定义了一个接口I时,如果后面类型A实现了I(中的方法),类型B也实现了I(中的方法),则当给一个为[int]I的字典实例化的时候,就要明确的在键值处写为A{},还是B{},因为如果就一个A类实现了接口I(中的方法),则你在实例化的时候写作3:{},则go编译器会根据你声明的定型直接将{}处理为A{},但现在有两个类都实现了接口I,此时就得你显式的给出来这个类型了:
    type I interface {ok() string}
    
    type A struct{}
    type B struct{}
    
    func (a A) ok() string {
    	return  "a"
    }
    
    func (b B) ok() string {
    	return  "b"
    }
    
    func main() {
    m := map[int]I{
    	3: A{},
    	4: B{},  //注意这样写的话末尾的逗号要有,否则会报错
    }
    
    fmt.Println(m[3].ok())
    fmt.Println(m[4].ok())
    }

但是按照stackoverflow上的逻辑来看, 如果我只定义了一个实现了I的类型,则m中实例化的时候,键值部分就能写{}而不用前缀个A或B了,但实际情况不是这样的:
    type I interface {ok() string}
    
    type A struct{}
    //type B struct{}
    
    func (a A) ok() string {
    	return  "a"
    }
    
    //func (b B) ok() string {
    //	return  "b"
    //}
    
    func main() {
    m := map[int]I{
    	3: {},
    //	4: B{},  //注意这样写的话末尾的逗号要有,否则会报错
    }
    
    fmt.Println(m[3].ok())
    }
上面的代码是报错的,说"missing type in composite literal",而将 3:{} 改为3:A{}后,执行就正常了.
通过上面这两段代码我觉得stackoverflow中说的和主题不符.我现在又有了新的理解,也是通过stackoverflow上的这个例子和官文中定义的Vertex结构体类型共同找到的灵感,即因为I是一个接口,可以被很多类型实现,所以在给它传值时,就一定要明确指定哪个实现了I的类,即使当前只有一个类实现了I中的方法.但像之前定义的Vertex类,因为go中没有继承的概念,所以一说到Vertex就只有一个,唯一的一个,它没有子类啥的,因此即使没有明确在{}前给出类型名,golang编译器也能推断出来.这可能就是所谓的top-level type吧,当然这是猜的.而在给字典赋值时又出现了问题:

func main() {
	type Person struct {
		Age int
	}
	var d map[string]Person = map[string]Person{
		"zhangsan":{18},
		"lisi":{19},
	}
	delete(d,"zhangsan")
	fmt.Println(d)
	d["zhangsan"] = Person{20}  //这句
	fmt.Println(d)
}
上面代码备注那句在给"zhangsan"赋值时,后面一定要写成Person{20},而不能写成{20}, 对于这个例子我的理解是,在给字典d初始化赋值时,会考虑到字典的键或值的实际类型,然后看这些类型是否为top-level type(按照上面最后一句我自己的理解走),去判断赋值时这个类型关键字是否可省. 而一旦初始化完成了,后面使用得到的对象进行赋值时,就不会考虑那么多了,就直接是拿你写的类型值去和d定义中的比较,正确则执行,不正确则报错,即使用初始化后的对象对字典进行更改时,就没有了推断的过程,只有比较的过程,因此此时的Person必须要写.

Mutating Maps
1.强调一点，变量要先声明后使用，或者在使用的时候直接声明，就第二点来说，比如elem和ok之前都没有声明，则可以在使用的时候使用短声明的方式直接声明: elem, ok := m[key]
2.这节主要讲的是map是可变的嘛，所以下面几点主要围绕着可变来说:
  a.改变某个键的值  m[key] = new value
  b.检索某个键的值  elem = m[key]  //前提是elem在前面已经声明，如果前面没有声明elem,则可以使用短声明的格式在赋值时声明:  elem := m[key]
  c.删除键值对,其实只要删除key就相当于将整个键值对都删了: delete(m, key)
  d.测试某key是否在map m中: elem, ok = m[key] //用这种形式的前提是elem和ok已经在前面声明了(如果前面没声明,要写成elem,ok := m[key])；就该例来说，如果key在m中则ok的值为true,elem为相应的值，如果key不在m中，则ok为false, elem为m中元素类型的"零值"
Exercise: Maps
1.练习下一轮的时候再看
Function values
0.functions are values too. //对于理解非常重要的一句话, 函数值是"函数作为值",即有参数类型是函数类型和或返回值是函数类型, 而不是"函数的返回值"
0.从这节的解释说明来看,function value指的是两个函数: 1是作为参数传给高阶函数的那个函数; 2是作为return返回值的那个函数
1.初看，函数即可以作为函数参数，也可以作为函数的返回值, 应该就是其它语言中所谓的高阶函数吧?! //之前说类似于python中的decorator,其实也不一样, python中对于decorator的解释是 参数和返回值都是函数,是和的关系(可以看cnblogs上关于python中decorator的笔记), 而这里的函数值说的是函数也可以作为值进行流转, 是或的关系, 即函数值出现在哪个环节都行
2.再看，有一点需要注意的，就是函数作为参数时的写法，这块乍一看不理解，但是分开来想还是可以理解的: func compute(fn func(float64, float64) float64) float64{},分解开看一下:
  func是定义函数的关键字
  compute是函数名
  fn是compute中的参数
  func(float64, float64) float64整体是fn的类型
  *.这点就是我要说的，正常情况下一个函数是由函数名，参数和返回值类型组成的，上面这条完整的表现了一个函数的这几点要素。而fn的类型是函数，所以这样子去理解"fn func(float64, float64) float64"就不难理解了
  *.再看例子，觉得上面这个*说的就有点不对了，"fn func(float64, float64) float64"当函数作为参数时，fn是参数名没错，"func(float64, float64) float64"作为fn的类型也没错，但是注意到一个细节，当函数作为参数类型时，相应的结构中没有函数名，这个是可以理解的，而且形参也是只有类型没有名，这个应该也理解，没了，都可以理解了，最后的那个float64是func(float64, float64)的返回类型
3.还是将tour上的那个例子写在这吧，看着例子好理解一些:
  import (
    "fmt"
    "math"
  )

  func compute(fn func(float64, float64) float64) float64 {
    return fn(3, 4)          
  }

  func main() {
    hypot := func(x, y float64) float64 {
      return math.Sqrt(x*x + y*y)
    }
    fmt.Println(hypot(5, 12))
    
    fmt.Println(compute(hypot))  //这块函数引用只用了函数名，需要注意一下;另外,compute中, return返回的是fn(3,4)而不是fn,也就是说return返回的是fn(3,4)的返回值,因此compute(hypot)返回的其实是hypot(3,4)的返回值,float64类型的math.Sqrt(3*3+4*4),即最后返回的其实不是一个函数, 而是一个值.
    fmt.Println(compute(math.Pow))
  }
*.关于上面这个高阶函数,还要讲一下传当函数A作为另一个函数B的参数时,在调用时的注意事项,见下面代码main函数中的注释部分:
    package main
    import "strconv"
    import "fmt"
    func A() int {
    	return 86
    }
    func B(fn func() int) string {
    	return strconv.Itoa(fn())
    }
    
    func main() {
    	fmt.Println(B(A)) //方法一,直接传入函数名,切记函数名不要加(),否则被传入的类型就不是函数A了,而是返回值的类型int
    	x := A             
    	fmt.Println(B(x))  //这个方法基本同上,就是给函数A取了个别名
    	y := func() int {return 86}  
    	fmt.Println(B(y))  //这是官文推荐的方法,即不用func声明函数,而是直接将函数作为一个表达式,最终得到一个函数类型的变量y
    }
4.假设A是一个高阶函数,其参数一或是返回值为函数B,当时想即然函数B无论如何也是要在函数A中执行的, 那为什么不直接在函数A中直接调用函数B呢,反而多此一举,先将函数B作为函数A的参数,然后再在函数A中对B进行调用?!, 现在我想明白了, 关键点在于"动态"两个字,假设我们明确知道要在函数A中调用的函数B是谁,那么无论是使用高阶函数还是直接在函数A直接调用函数B都是没有问题的. 但问题是, 我们将函数A给抽象成可以在函数体中执行任何函数B的函数,此时就必须要用高阶函数了,因为我们不知道这个函数B不是个具体的函数了.知道了这点,再一想一下常用的map函数,它接受一个数据集,和一个处理数据集的函数, 此时你再想想, 100个人可能有100种处理数据集的想法, 你怎么能做到直接在map函数中调用一个函数逻辑去满足这100个人的处理逻辑呢?此时只能使用高阶函数,将map函数的参数类型设置成函数类型, 这样你就可以传入任何的函数, 从而可以用不同的逻辑处理数据集. 如果golang本小节是要讲高阶函数,其实它举的这个例子对于理解什么时候使用高阶函数是没有帮助的, 这只谈到了用法, 但这个例子执行完过后,脑子里并不知道什么时候会用到这种结构.
Function closures
1.什么是closure?
  ::closure是一个函数值，我感觉再精确一点，closure就是一个作为(返回)值的函数；但是还有一个约束，就是这个函数返回值的body部分引用了body外的变量，body外应该指的就是和return同级的一些变量；这句话还可以和上一句一样说的更精确一些，closure其实就是一个无名函数，它作为函数的返回值，return的参数。即函数的返回值也是一个函数，但是还有一点需要说明的是不是随便一个被返回的无名函数都叫closure,这个无名函数体内还要引用和return同级的变量才可以；总结一下closure的特点：
  a.closure函数是一个无名函数;
  b.closure函数是某个函数的返回值;
  c.这个内部的无名函数体中要引用父函数中的变量 
  d.closure一般作为return的参数
2.这节通过例子还是有两点需要注意的：
  a.同时给多个变量赋值，这个其实也不算新东西:
       pos, neg := adder(), adder()    //准确来说应该叫同时声明多个变量并赋值
  b.下面这个例子讲到了精髓,在下面的例子中,所谓的function closure并不是adder()这个函数, 而是它的返回值"func(x int) int",而重点在于返回值中的函数引用了outer的变量sum,而closure function的作用可以理解为: 将外部函数adder理解为一个类,将每次adder()理解为得到一个实例, 类的实例说白了就是在将这个类复制到另外一块内存上嘛.使用adder()多次赋值就会得到多个实例,这些实例之间没有交集,是在不同的内存区域上, 但对相同实例的多次调用时,上一次的调用会影响下一次,因为两次调的是同一个实例嘛,所以下一次调用时会引用上一次得到的sum;(这么说可能不是真正的设计逻辑,但是对于前期理解还是有一点帮助的)//这段话要是不明白根据官网例子的结果多推敲一下就明白了
  func adder() func(int) int {
  	sum := 0
  	return func(x int) int {
  		sum += x
  		return sum
  	}
  }
  
  func main() {
  	pos, neg := adder(), adder()
  	for i := 0; i < 10; i++ {
  		fmt.Println(
  			pos(i),
  			neg(-2*i),
  		)
  	}
  }   
  *.你可以将adder()理解为类, pos,neg := adder(), adder()相当于类adder的实例化,得到两个实例pos和neg, 此时因为是两个实例,所以操作pos时对neg是没有影响的, 反之亦然, 但正如上面例子所说, 多次操作同一个实例时,如果多次调用都会用到同一个变量(引用closing function中的),则前面调用时产生的结果会影响会面调用时该变量的初始值,原因很明显, 同一个实例中,同一个变量在内存中的地址是固定的.//这段话也可以理解为function closure(函数闭包)的使用场景
*.上面关于function closure的说法应该不完全正确, 感觉只是其中的一种应用形式.//但function values一节说function values可以用于函数参数或函数返回值, 而这一节又说在function closure中引用closing function中的变量,所以只有匿名函数作为返回值才满足可以在函数体中调用closing function中变量的情况.
**.在看net/http/server.go的源码时发现了函数的另一种用法:
    import "fmt"    
    
    func main() {
         type X func(int,string)
         Q := X(func(y int, z string){fmt.Println(y,z)})
         Q(3,"6")
    }
    上面看到的写法是直接将匿名函数作为变量值,即 a := func(){...}, 之后便可以使用a()来进行函数调用; 而上面这个例子中是先声明一个函数类型的变量X, 用的时候有点不一样,将匿名函数作为X的参数类型,而得到的函数类型Q,可以像Q(y,z)这样使用. 这样的好处是,声明了一个函数类型,我们可以用这个类型去扩展一些方法.而像刚刚说的直接将函数作为表达式的情况就不能用得到的a去扩展方法.
*.对照上面的这个自定义函数类型的写法,我又找了个例子,引发了我的思考,对比上下这两个例子,对于由type自定义的类型到底应该如何赋值?:
    //type app []int
    func main() {
      //a := app{1,2,3}
      //var a app = []int{1,2,3}
      //var a app = app{1,2,3}
      //var a app = app([]int{1,2,3})
      //fmt.Println(a)
}

Exercise: Fibonacci closure
1.练习部分下一轮再说
Methods and interfaces
Methods
1.Go语言没有类这个概念
2.虽说Go没有类的概念，但接下来引出Go语言有方法的概念，我们知道方法这个词一般是对类中函数的称法；既然Go没有类，那么Go中的方法是怎么实现的呢?简单来说就是在原有函数定义的基础上，在func关键字与函数名之间加一个在Go中被称为receiver的参数，这么个组合在Go中就叫做方法
3.从实例来看，这个receiver仅仅是为函数体提供引用数据，再说白点就是receiver中定义的数据，在相对应的函数中都可以使用
4.下面这段代码叫做:Abs方法有一个类型为Vertex名称为v的接收器:
  type Vertex struct {
    X, Y float64
  }
  
  func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
  }
  将引用的部分也写下来吧，应该有助理解:
func main() {
  v := Vertex{3, 4}
  fmt.Println(v.Abs())
}   //从调用形式来看，和kotlin中类的扩展意思差不多，可以看一下引用，是将Abs()作为v这个类的方法去引用的，而且Abs()函数体可以使有v类中的成员
5.一个简单的例子:
    package main
    import "fmt"

    type Person struct {
    	name string
    	age int
    }
    
    type Car interface {
    	drive() string
    	stop() int
    }
    
    func (p Person) drive() string {
    	return p.name
    } 
    
    func (p Person) stop() int {
    	return p.age
    }
    
    func main() {
    	var YQ Person = Person{"YangQiang",30}
    	var baoshijie Car = YQ
    	fmt.Println(baoshijie.drive())
    	fmt.Println(baoshijie.stop())
    }
上面这个例子就是接interface也给带出来了, 如果要说interface的常用方法,上面这个例子还不够,如果再定义一个type Alien struct{}类型,然后Alien类型再实现drive()和stop()方法,这样,"var baoshijie Car = "后面的值就即可以是YQ,也可以是Alien了,因为这两个类型都实现了Car这个接口的方法,而具体baoshijie的值是YQ还是Alien,就根据实际需求了. //抽象出来说明就是: 接口中定义的方法可以被N多的类型实现, 但不同类型有不同的实现方法, 当一个变量声明为相应的interface类型时, 可以根据实际情况将相应实现其方法的类实例赋给变量.


*.也就是说这节说的receiver, 说白了就是一个"类"!
Methods are functions
1.这一节就着重强调了: method is just a function with a receiver argument
2.拿一个例子来说明了，将method的receiver部分放到function的参数位置，则function和method实现的功能是一样的(不知道是否所有的method和function都可以这样转换，这个后期再讨论)
  type Vertex struct {
    X, Y float64
  }
  方法的形式:
  func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
  }
  引用的时候:
  v := Vertex{3, 4}
  fmt.Println(v.Abs())   //Abs()里面没有参数，因为Abs()函数体可以直接从v中取
                       //这遍看突然发现，方法的引用好像不对，打印函数中参数应该是v.Abs(),现在只写了Abs()  //已在Abs()前补上receiver v补上
  
  函数的形式:
  func Abs(v Vertex) float64 {
    return math.Sqrt(v.X*v.* + v.Y*v.Y)
  }
  引用的时候:
  v := Vertex{3, 4}
  fmt.Println(Abs(v))  //Abs()里面要加参数v,否则函数体中引用的v.X和v.Y就会报错了
*.还是上面说的，就现在的理解method之于function来说只是给function加了一个环境(用环境这个词好像不太形象，理解就好。)，这个环境的数据在function中可以引用，仅此而已(强调：是目前这么理解!)
Methods continued
1.前面讲的方法，接收器的类型是struct,其实对于非struct类型也是可以的
2.receiver的类型必须是在method所在的包内声明，在其它包中声明的类型(包括内建的包)不能作为本包method中receiver的类型  //举例来说, 像int, float64这样的内建类型,因为它们不是在你定义方法的那个包中声明的, 所以你不可以直接将它们作为接收器类型,如果确实想用其它包中或是内建的类型, 首先要保证该类型在本包内可访问(这主要是针对非内建包,因为内建的许多类型所在的包都是默认导入的),然后再使用"type 别名 非本包内声明的类型名"的方式,在本包内声明一下, 然后再使用这个 "别名" 作为某方法的接收器类型就可以了.
3.定义一个类型，使用关键字"type,后接类型名，最后接类型" ,如:type myfloat float64
  type MyFloat float64
  func (f MyFloat) Abs() float64 {
    if f < 0 {
      return float64(-f)
    }
    return float64(f)
  }
Pointer receivers
1.这一节的节名叫"指针接收器"，该指针和c中的指针意思是一样的，后面应该会讲Go里没有指针之间的运算
2.其实重要的是要理解指针的概念，指针的概念弄明白了，这一节自然也就没啥了.首先内存说起，内存是一个地址空间，可以把内存想象成一个大房子，里面有N个房间，每个房间都有自己的编号,1,2,3...,再来说变量，编程语言中声明一个变量，其实就是在内存中给这个变量分配一块空间，空间大小由变量的类型决定。变量声明其实最终这个变量得到的是一个内存中的地址，拿上面的房间举例来说就是，var a int,对应下来可能就是将第一间房间的房号1给变量a,而第1，2，3，4间房是分配给a的空间，以后再给变量a赋值时其实是先定位到1这个位置，然后向1234这四个房间记数据，从a中取值也是，先定位到1这个位置，然后把数据取出来；下面该说指针了，这个指针对应的就是这个位置1，说白了就是指针其实就是内存中的地址。而指针变量就好理解了，就是这个变量中存的是指针，再换个说法变量中存的是内存中的地址。而指针变量前加上*，指的就是指针变量中的地址指向的值，这句说的不太明白，举例来说，变量a在内存中的地址是1，变量a的值是"abc",有一个指针变量b,b中存的是a的地址，则b的值是1，*b是"abc"(即指针变量b的值a所指向的内存空间的内容)
*.指针这个东西其实只要明白了内存结构，还有声明变量的实际情况就很简单，有时间要回看一下王爽的16位汇编。上面这些描述不是太准确，只能帮助理解一下
3.Go中指针最重要的一点就是，接收器如果是指针引用，则会修改指针变量值所指向的实际内容。下次再引用该指针变量值的时候，该指针变量值的指向就已经是修改后的了；如果接收器就是普通类型的变量，则方法中引用该接收器变量内容实际上是先对该内容做个备份，然后引用的是备份的内容。下次再使用该接收器的变量时还是原值，因为之前根本就没有对接收器的原始值做修改
*.这一节说的就比较不太好了，后面有机会这块用心再总结一下
4.这节的例子，如果Scale接收器的类型为Vertex则最后的值是5，如果是*Vertex最后的值是50   //我的理解是，本质上还是对类的操作，我们可以将最开始声明的类理解为"模板"，将类的实例化理解为"复制一份模板并自定义相应的修改"，指针类型的接收器特点是:"不是在copy的模板上修改，而是直接修改类声明的数据，即直接修改原模板的数据"，而普通类型的特点是"将原模板复制一份，然后在复制后的模板上做修改，即原模板的数据不会被改变"，此时再去看这小节的例子就可以理解了，再啰嗦一句:指针作接收器是在内存中声明类时分配的内存区域上直接做修改；普通类型作接收器是将声明类时内存区域中的数据复制一份到内存的另一个区域，然后在复制后的这块内存上做修改，并不会影响类声明时分配的内存区域上的内容；其实平时说的"类的实例化"的行为应该和这里说的普通接收器的行为一致.
5. receiver type如果是指针的话，不能是*int,*float64这些，必须是 type a float64,这里*a可以作为receiver type; 我不知道原文件咋翻译  //也可以理解为系统内置的类型不能直接作为指针接收器的类型，即要不自定义一种类型，要不将这些内置的类型再封装一层(type 别名 内置类型)才能做指针接收器类型
6.func (v *Vertex) Scale(f float){}读作:定义在*Vertex类型上的方法
7.接收器的类型为指针的话，对该针指的指向进行修改，修改的是原始位置，即后面再引用该指针的时候，使用的值是之前修改过的；但接收器的类型为普通类型的话，则修改的是这些变量的备份，不会影响原值；普通函数的参数类型就属于这种(修改的是副本)
Pointers and functions
1.这节主要看的是例子，method用function实现，其实也就是将method的receiver部分给放到function参数的位置    //需要注意的是Scale()函数中第一个参数值为&v,因为指针变量存的实际上是另一个类型的地址，所以这里用到了&符号
Methods and pointer indirection
1.function中的参数是啥类型，调用该function时参数类型绝不能写错(这个不像receiver中的类型，明明类型是指针或是普通类型，但调用的时候可以使用普通类型或指针进行调用，Go优化了这部分逻辑)  //我写这句话其实是为了强调一开始讲指针时的一个调用例子，即本应该是(*p).X,但在Go中直接写p.X就好！但是如果指针作为函数参数而非接收器时，在调用函数时，该参数一定要用指针调用的形式而不能用普通变量调用形式(其实关键点就是那个&符号，指针参数有，而普通类型的参数没有)
  var v Vertex
  ScaleFunc(v, 5)  // Compile error!
  ScaleFunc(&v, 5)  // OK
2.上面1说了，当方法的接收器类型为指针时，引用方法的时候，接收器可以使用value(普通类型),也可以使用pointer(地址)  //猜测Go在处理指针类型的接收器调用函数时，如果你没在指针变量前加&的话，Go会隐式的帮你加上，这个行为猜测是编译阶段编译器处理代码时给自动加上的；但如果指针作为函数参数时，猜测由于Go语言没有在编译阶段加上这个逻辑，所以在函数调用时，如果函数参数为指针类型则一定要使用&符号，其实感觉函数参数如果是指针类型也可以处理一下，无非是处理之前先检测一下类型呗，当然啊这句注释完全是为了好理解的一个猜测.
  var v Vertex
  v.Scale(5)  // OK
  p := &v
  p.Scale(10) // OK
  *.作为约定,Go在解释v.Scale(5)的时候会自动解释为(&v).Scale(5)
3.还要注意指针中&号与*号的简单作用，给个简单例子看一下吧:
    package main
    
    import (
    	"fmt"
    )
    
    var x = 5
    
    func main() {
        var p = &x
    	
    	fmt.Println(x)
    	fmt.Println(p)
    	fmt.Println(&x)
    	fmt.Println(&p)
    	fmt.Println(*p)
    	fmt.Println(*(&x))
    	fmt.Println(**(&p))
    }
    输出为:
    5
    0x190004     //这几个地址每次输出的值可能会不一样
    0x190004
    0x40e128
    5
    5
    5
Methods and pointer indirection(2)
1.上面也提过，function参数是啥类型调用时就得使用啥类型
  var v Vertex
  fmt.Println(AbsFunc(v)) // OK
  fmt.Println(AbsFunc(&v)) // Compile error!
2.但是method不一样，method中接收器的类型为value时，调用该method时也是即可以使用value也可以使用pointer类型
  var v = Vertex{3,4}
  var p = &v
  fmt.Println(v.Abs())  // OK
  fmt.Println(p.Abs())  // OK
  *.p.Abs()会被解释为(*p).Abs()
**.对上两小节的主要内容总结一下吧:
    1.无论方法的接收器是value类型还是pointer类型，在进行调用时都可以使用value类型或是pointer类型进行调用, 编译器会进行相应的转换
        a.接收器为value类型,则如果使用&p进行调用，则编译器会将&p转化为*(&p)
        b.接收器为pointer类型，则如果使用v进行调用,则编译器会将v转化为&p
    2.接1说，但是函数定义中的参数如果是value类型则传参时必须是value类型，如果是pointer类型则必须传pointer类型  //这个就不说了上面都有例子
  /*当接收器类型为指针时,在调用相应的方法时,无论你是使用指针类型进行调用还是使用值调用,调用结果是一样的,都遵循"方法定义时所使用的接收器类型". 换句话说,当接收器炎指针类型时,如果你使用指针类型调用,正好,这是常规逻辑; 如果你使用的是值调用,则在真正执行的时候,编译器也会根据相应的方法在定义时前面的接收器类型,给你的值调用前加上个"&",然后再进行执行. 也就是说,当接收器为指针类型的变量时, 你在调用相应的方法时,无论是使用的值调用还是指针调用,最后执行的语句都是一样的,即都是指针调用,因此得到结果也是一样的.就下面的例子而言,ZS声明时的类型为普通Person类型,当你引用的时候写的是:
ZS.multiply() 时, 在执行前会检测multiply()方法定义时的接收器类型,将该句处理为:(&ZS).multiply(),然后再执行.
而当你写的是: (&ZS).multiply()时,同样在执行前还是会检测multiply()定义时接收器的类型,发现没问题,则预处理对它啥也不做,原样执行.
也就是说: 关键点在于golang在调用方法的时候,会根据方法在声明时接收器的类型去调整你实际调用时使用的变量类型.
    func (p *Person) multiply() {
    	p.name = p.name + "-"
    	p.age = p.age + 3
    }
    
    func main() {
    	ZS := Person{"zhangsan",18}
    	fmt.Println(ZS.name, ZS.age)
    	ZS.multiply()  //ZS-> (&ZS)
    	fmt.Println(ZS.name, ZS.age)
    	ZS.multiply() //ZS-> (&ZS)
    	fmt.Println(ZS.name, ZS.age)
    }*/
    
  /*下面的multiply()方法的接收器是普通类型,而下面的main()函数中,ZS变量是指针型变量,此时当我们在调用multiply()方法时写的是:
    ZS.multiply(),则编译器会根据multiply()方法在定义时前面接收器的类型,自动将指针类型引用转为值引用,即改为: (*ZS).multiply().
    如果你在调用multiply()时,直接写的就是(*ZS).multiply(),则编译器同样还是在执行该句前检测multiply()方法定义时的接收器类型,发现调用的类型和定义时的一样,则不会更改什么,原样执行
    func (p Person) multiply() {
    	p.name = p.name + "-"
    	p.age = p.age + 3
    }
    
    func main() {
    	ZS := &Person{"zhangsan",18}
    	fmt.Println(ZS.name, ZS.age)
    	ZS.multiply()  //ZS-> (*ZS)
    	fmt.Println(ZS.name, ZS.age)
    	ZS.multiply() //ZS-> (*ZS)
    	fmt.Println(ZS.name, ZS.age)
    }*/

Choosing a value or pointer receiver
1.这一节说出了在声明method时使用指针作为接收器类型的两点原因：一是，可以直接修改pointer指向的值；二是，避免了方法调用时要先做备份，然后对备份修改时的性能损失(接收器类型为value时,使用value类型的变量对方法进行调用时,要先将value类进行copy,得到一个value类型副本,然后在副本上进行操作嘛,这样一来,如果value类型数据较大,则性能损失比较严重. 话又说回来了,各有优缺点, 使用value做为接收器时,不同的value类型的变量之间没有影响,因为每个value类型变量在调用相应的方法时都会先copy一个自己的value类型副本)
2.通常来说相同类的receiver类型不能同时存在，不能混用,即如果有func (a A) x,则以后类型A只能以value类型作为方法的接收器, 不能出现func (a *A) y这种形式, 反之为然. //本节并没有说明为什么不能混用,说在下面几节能找到原因. 我写代码实际测了一下,编译这块并没有什么问题,一个是(a A),一个是(a *A)编译执行也都是没问题的. //看例子应该特指的就是某个类型实现接口中的多个方法时,接收器要么都是A,要么都是*A,推荐是一个方法是A,另一个方法是*A,但下面有个链接也举例说了这个推荐是误导性的.无论最后结论什么样,当前下面第3点总结的这些行为先记住.
In general, all methods on a given type should have either value or pointer receivers,这句话里,on a given type这里的type应该就是特指的接口类型,all method指的是接口中定义的N个方法, 后面either...or...中自然指的就是value和pointer接收器类型了
3.为了弄求清上一条2所说的在编写代码时最好(同一个类)接收器的类型(value,pointer)不要混用,总结了一下:
    /*
    1.当未引入接口类型时,某个方法的接收器类型无论是value型还是pointer型,在调用的时候你都可以使用value型或pointer型进行调用(具体为啥上面已有详解).
    2.当引入接口类型时,变数就来了, 这里要分为两种情况:
        a.不显式的引入接口类型变量(或称为不将接口类型与接收器类型相关联), 此时可以忽略接口对方法进行调用,而且无论方法定义时用的接收器类型是value还是pointer,调用时还是上面讲的常规调用,即使用value或pointer都可以.
      type V struct {X,Y int}
      type I interface {ok() int}
      func (v V) ok() int{  //这里的接收器无论是V还是*V,由于主函数中没有引入接口类型I,而是直接调用的方法,所以,见下面注释
    	  return 666
      }
      func main() { 
        //var i I
        a := V{1,2}  //这里的值用value,V{1,2}或pointer,&V{1,2},都是没问题的,下面的fmt调用都不会出错.
        //i = a
        //fmt.Println(i.ok())
        fmt.Println(a.ok())
         
      }
        b.显式的引入接口类型变量(或称为将接口类型与接收器类型相关联), 此时
              <1>.方法定义时接收器的类型为value时,基本同上, 即,既可以将value型变量赋给接口类型变量,也可以将pointer类型赋给接口类型变量,最后使用接口变量对方法进行调用
      type V struct {X,Y int}
      type I interface {ok() int}
      func (v V) ok() int{  //因为实现接口I的ok方法时用的接收器为value,所以,见面注释
    	  return 666
      }
      func main() { 
        var i I
        a := V{1,2}  //这里的值用value,V{1,2}或pointer,&V{1,2},都是没问题的,下面的fmt调用都不会出错.
        i = a
        fmt.Println(i.ok())
         
      }
              <2>.方法定义时接收器的类型为pointer时,特例就来了,此时只可以将pointer类型的变量赋给接口类型变量,然后使用接口类型变最对方法进行调用; 如果此时将value类型的变量赋给接口类型的变量,则会报错(说value类型未实现接口).
      type V struct {X,Y int}
      type I interface {ok() int}
      func (v *V) ok() int{  //因为实现接口I的ok方法时用的接收器为指针类型,所以,见面注释
    	  return 666
      }
      func main() { 
        var i I
        a := &V{1,2}  //这里的值必须要用指针,如果将"&"去掉,下面fmt中的调用就出错了
        i = a
        fmt.Println(i.ok())
         
      } 
但虽说混用时,只能将pointer类型赋给接口变量,但使用指针变量进行调用时,接收器类型是指针的,在原接收器类型对象上修改,接收器类型是value的,则还是在副本上修改(这是否正是接收器类型不能混用的原因,一混,有的在原位置改,有的在复本上改, 最后就乱套了?),这一点和我想的不一样, 原来我想的是指针变量都是pointer类型了,肯定无论实现接口中方法的接收器是value型还是pointer型都在接收器对象原位置修改.现在想来golang尊重的是方法声明时接收器的类型:
 type V struct {X,Y int}
  type I interface {
	  ok() int
	  yes() int
  }

  func (v V) ok() int {   //接收器为value
      v.X = v.X*10
      return 0
  }

  func (v *V) yes() int {  //接收器为pointer
    v.Y = v.Y * 10
    return 0
  }

  func main() {
	  var i I
    r := &V{1,2}  //因为上面混用,所以这里只有将指针类型值赋给r才合法
    i = r
    i.ok()  //作用在v副本上
    i.yes()  //作用在v原位置
    fmt.Println(r.X)  //输出1
    fmt.Println(r.Y)  //输出20
  }

*/  
结论:那么到底为什么不能混用呢? 既然上面这段代码已经证明了,既使V和*V混用去实现一个接口,只要在给接口变量i赋值时赋指针值即可,因为r在调ok()时改的就是r的副本,在调yes()时就是在r原位置改的.所以逻辑都是通的怎么就不能混用了呢?  在stackoverflow找了个相关的链接,状态好的时候可以看一下,可能会有答案,同时里面还给出了什么时候使用value receiver什么时候使用pointer receiver( https://github.com/golang/go/wiki/CodeReviewComments#receiver-type): https://stackoverflow.com/questions/27775376/value-receiver-vs-pointer-receiver/27775558#27775558    这个链接又说可以混用,说原文说不能混用是误导别人: https://github.com/golang/tour/issues/97
Interfaces
1.首先Interface是一种类型，在定义Interface类型的时候，body中是N多方法的集合，需要注意的是:body中的这些方法只有方法名及相应的返回值类型，并没有方法的具体实现
  type Abser interface { Abs() float64 }
2.根据例子来看，interface类型的用法一般是：首先要明确一点，interface类型body中的不是function,而是method(即带有receiver的function);其次和interface这节没关系，要说的是method的常用调用方法是 "receiver.method_name()",方法最常用的形式大概是"多个同名不同receiver类型的方法"，虽说调用的形式都是相同的,但编译器会根据receiver的不同，从而选择相应的method执行，这个看看本节的例子很好明白
3*.对于理解比较重要的一句话是:"A value of interface type can hold any value that implements those methods"，翻译过来是"给接口类型赋的值，可以是实现接口中方法的任何值"，如果前面method相关章节中没有好好看，好好理解的话，这句好可能会有些不明所以；我们知道所谓的方法(method)，就是带有接收器(receiver)的函数(function)，而其中有一些描述方法的话，大概意思是"接收器(receiver)类型实现的方法(method)"; 然后再看上面的那句话，应该就能明白了，举个例子:
  a.如果定义了一个接口类型Abser,里面的方法特征是: Abs() float64,就这一个方法
  b.定义一个Abser类型的变量a  "var a Abser"
  c.此时变量a的合法赋值，要看具体都有哪些类型实现了Abs()方法. 假如声明了两个方法，一个是"func (v *Vertex) Abs() float64 {}",另一个是"func (f MyFloat) Abs() float64 {}"，则在给a赋值时，只有类型是*Vertex和MyFloat的才合法。这是为什么呢？因为你后面要使用a.Abs()进行调用，如果a是除*Vertex和MyFloat之外的其它类型，则在调用时是会出错的，因为其它类型没有实现Abser接口中的Abs()方法(这个在编译的时候编译器会检测a值的类型，是否实现了Abser接口中的Abs()方法，如果有则通过，如果没有则报错)
*.其实想想，肯定是有逻辑在里面的，首先interface类型中声明了N多个(N大于等于1)方法特征(基本上就是方法名，还有返回值类型)；再者你在interface中声明了方法后，后面肯定是要实现的，不实现的话，interface类型中定义的方法特征就没意义了；再者你方法实现了的话，肯定又是要引用的，不引用的话，你实现的方法又没意义了；而方法的引用一般是"接收器类型的变量.方法名"；而给interface类型的变量赋值这块，你想想这个变量的类型是啥呢？其实结合上面这些因素，interface类型的变量被赋值的类型是实现接口中定义的方法的接收器类型是最合理的。(最后一句话对于理解很重要)
Interfaces and implemented implicitly
1.我们平时所说的"类型实现接口"是指"类型实现接口中定义的方法"
2.在"类型实现接口方法"时，是隐式的，没有显示的关键字来说明"类型实现接口方法"
3.类型对接口的隐式实现，好处在于将定义与实现分离了，也就是说对于接口的定义你可以放在任何包中，然后在不同的包中你可以对接口有不同的实现(这块还是要再啰嗦一下，一定要注意从接口的声明，到使用的步骤:1.肯定是先定义接口;2.实现接口中的方法，这时要注意Go中的方法其实就是函数加个接收器，而接收器的形式是"接收器名 接收器类型"；3.定义接口类型的变量，这里要尤其注意，这里的"接口类型"指的是实现接口中的方法时的"接收器类型"，即如果接收器类型是int,你在定义接口变量时给了一个float类型，编译时是会报错的；4.其实接口这块还是有一点点绕的，接口中的一个方法，在实现时，可以根据"receiver类型"的不同有多个实现，而在给接口变量赋值时，变量值的类型一定是已经实现了接口中方法，否则会出错，这个可以参考上一节“Interfaces”的例子来理解一下
*.因为接口用的还少，目前看来感觉接口就是"定义一个或多个方法，但是并没有实现"，好处是你可以将这个接口放在任何包里，因为本来也不带实现代码，所以在哪个包里放着都一样；好处是你可以在不同的包里对接口里的方法有不同的具体实现，且被实现的方法中"receiver类型"也可以是不一样的；说白了就是灵活性增强了。现在虽然说勉强会用接口了，但是因为实现的代码少，总是隐隐觉得不安，觉得理解的还不够透彻。
Interface values
1.这节的标题叫"Interface values"，相应原文大概要表达的意思:a.interface value可以被认为是一个由"值"和"值相对应的实体类型"组成的"元组"， 说白了就是(value, type)  //这个(value, type)只是为了让我们好理解的一个假想,举个例子吧, 
    type I interface {ok() int}
    type V struct{X int}
    func (v V) ok() int{}
    var i I
    r := V{1}
    i = r
    i.ok()
    上面代码中,所谓的(value,type)指的就是(i, V), 所以说一个接口可以有多个不同的接口值(如X,Y,Z实现了接口I中的ok()方法,则此时的接口值有四个(i,V),(i,X),(i,Y),(i,Z))
2.这里面还有一个字符串叫"underlying concrete type"， 这个玩意可以用上面接口例子中的内容去理解，即接口中只定义了方法名，下面要实现该方法，而方法是有接收器(receiver)的，一旦有类型实现了接口中的方法，再给相应接口类型的变量赋值时，只能赋这些实现了接口中方法的类型，用其它类型的值就会报错，而这里开头说的"underlying concrete type"指的就是这个实现接口中方法的接收器(receiver)类型. 
3.最后一段话初看者其实不好理解，说的是在"interface value"上调用一个方法，会在"interface value"相对应的"underlying type"上执行相同方法名。这句话现在看很好理解, 假设I是一个接口, ok()是它里面定义的一个方法, 而类型V实现了ok()方法(或说V是ok()方法的接收器类型),当声明一个接口类型变量var i I = V时, 使用接口类型i调用ok()方法,i.ok(), 实际上执行的是V.ok(). 这么设计也好理解,因为i虽说是I类型,而ok()方法又是I中定义的, 但I中的这个ok()方法只有一个名,没有实际的逻辑.所以最终调用ok()方法的还是上面所谓的这个"concrete type",就本例来说是V.
Interface values with nil underlying values
1.先要明白标题指的是什么东西，举例来说:
type I interface { M() int }
type T struct { S string }
func (t T) M() int {}
var i I
var t1 T
i = t1
t1.M()
首先说上面这段代码是错误的,因为struct和map,slice不同,struct只声明不赋值时,默认0值不是nil,只有所有的指针变量不赋值时都是nil,所以上面代码要改为:
type I interface { M() int }
type T struct { S string }
func (t *T) M() int {}
var i I
var t1 *T   //这里t1因为没有显式赋值,所以编译器给赋了个结构体指针类型的零值,nil
i = t1
t1.M()
也就是说这节主要是针对map,slice和所有类型的指针变量来说的.
2.interface value如果保存的实体类型的值是nil,则这个interface value也不是空的。通过例子来看:
    type I interface {ok() int}
    type T struct { S int }
    
    func (t *T) ok() int{
    	return 666
    }
    func main() {
    	var i I
    	var t1 *T
    	i = t1
    	if t1 == nil {   //此处为t1 == nil时,条件是成立的,因为结构体指针t1没有被赋值,如果换成i,则i == nil是不成立的.但是从输出结果来看i和t1输出的都是<nil>,这块有点不太理解内部是怎么实现的
    		fmt.Println("nil!")
    		fmt.Println(i)
    		fmt.Println(t1)
    	}
    }

Nil interface values
1.标题所谓的"nil interface values"说白了就是定主的了接口类型变量,var i I,但没有给i赋值,此时i会被编译器赋值,nil. 这种情况下使用i直接调用接口中的方法,如上面所说的i.ok(),则会产生一个run-time错误,其因想想也简单, 此时没有和i挂购的concrete type, 你执行谁去?。这和有没有类型实现I中的方法没有关系, 假使V类型实现了I中的方法, 但你在var i I之后, 没有给i赋值V也没用啊.
  var i I  //定义接口变量i
  i.方法()  //此时用i调用实现的方法时,由于接口类型的i没有被赋予一个concrete type就直接调用接口中的方法了, 因此会抛出运行时异常)
The empty interface
1.空接口比较好理解，指的是按口里面没有定义方法，即就是一个type I interface{ }, 空接口可以保存任何类型的值，因为任何类型都至少实现了0个方法
2.空接口常用于编码处理一些未知类型的值，例如fmt.Print函数,它的参数类型为"a ...interface{}",看着好像就一个形参,a,类型为空接口interface{},但你要注意空接口前面还有三个点呢, 表示任意多,即这里表示任意多个空接口类型的值, 而所有类型都实现了空接口,所以说白了就是fmt.Print这个函数中放啥类型都行, 多少都无所谓.
3.上两句都可以不看了，说白了就是如果之前定义了一个变量I为空接口类型， type I interface{}， 而且定义了一个参数为空接口类型的函数，则调用这个函数时，可以使用任何值作为这个函数的参数，无论这个值是什么类型，因为前面说了，任何类型都至少实现了0个方法. 假使再在这个空接口类型前加上三个点,就不仅是可以传任何类型值,而且数量还可以是任意多.
***
接口这一节主要是要弄清几个单词的内容:
1.Interface values      // (value, type)
2.nil underlying values   //简单来说就是给接口变量赋值了, 但赋的值是未初始化且其类型的零值为nil. (underlying type指的是实现了接口中方法的那个类型, underlying value自然指的就是实现了接口中方法的那个类型的值了, 而现在这个值是nil,说明我们给这个underlyig type变量只声明了, 未赋值. 这么说是不完全正确的,正确的应该是: 对于slice类型和map类型,和其它类型的指针类型(即类型为map[T]S, []T, *int, *float64等是正确的),因为一般的类型你只声明不赋值都会有一个0值,这个零值除了刚说的那几种是nil外,都不是nil.
3.nil interface values   //通过看官文的例子,首先,对于nil interface values来说,大的概念还是interface value, 而interface value 说白了就是var i I中的i, 而nil interface value指的就是声明了接口变量,但没有给接口变量赋值,此时的接口变量的默认值就是nil,和上面有没有某个类实现了接口中的方法无关. 而调用没有初始化的接口会报错.
4.empty interface   //这个没啥说的就是接口定义时没有定义方法
***
Type assertions
1."类型断言"的语法为: " i.(T) ", 其中i是接口类型变量,T是某个类型, 官文解释为: 看看T是否为i的实体类型. 通俗一点来讲就是: 看当前接口变量i协值的类型是否为T, 如果是则将T类型的值返回, 如果不是直接就抛出致命错误. //通过看官文的例子, 觉得空接口类型有些时候挺有用的, 因为在后面可以根据需要给空接口类型的变量赋任何类型的值. 我想到的一个类型断言使用场景: 有多个类型X,Y...都实现了接口I中的方法, 然后在代码中使用i.(X|Y...)去判断最近一次给接口i赋的值的类型是否为X|Y... .
  *.其中有个特殊情况就是有多个类型都实现了接口I,但并未将任何一个相应类型的值赋给接口变量i,按照上面讲的, 此时i就是nil interface value.
2.上面1中说的是我想到的场景,而落实到代码上时,有两种形式:
  a.1个返回值: t := i.(n)   如果最近一次接口变量i的值类型为n,则将最近一次赋给i的值赋给t,否则发生panic.
  b.2个返回值 t,ok := i.(n) 如果最近一次接口变量i的值类型为n,则将最近一次赋给i的值赋给t,将布尔值true赋给ok, 否则将n的零值赋给t,将false赋给ok,并且不会发生panic
*.再加一句吧, 上面已经说了类型n必须是实现接口I中方法的.如果你随便用一个未实现接口I中方法的类型去替代n,则会报错告诉你,你所用的这个类型未实现接口I.
Type switches
/*这里的switch的作用是在一个结构中判断当前接口i中存放的到底是哪个类型(假设已经有多个类型已经实现了接口中定义的方法)的值. 而每个case T,就是一个判断条件.当接口变量i当前值的类型为某个关键字case后面的T,则执行相应的代码.如果接口变量i中存放的类型和任何一个关键字case后的类型都不匹配,则执行default关键字下面的代码.
而在落实到代码上时, 还有两种情况:
  a. 当switch条件部分没有变量部分时,仅仅是做类型的匹配以及执行匹配上类型的代码块;
        type I interface {ok() int}
        type T struct {S int}
        
        func (t T) ok() int { return 666}
        
        func main() {
        	var i I
        	t := T{2}
        	i = t
        	switch i.(type){   //因为i.(type)前面没声明变量,因此代码中不可引用i.(type)的返回值
        	case T:
        		fmt.Println("T")
        	default:
        		fmt.Println("other")
        	}
        }
    b. 当switch条件部分有变量时, 如果某个关键字case后面的类型T匹配上了,则变量的类型为T,值为当前接口类型值; 如果所有关键字case后面的T都未匹配上,则变量的类型和值同接口变量相同.
-----当前接口变量值的类型和某个case后面的类型匹配-----
        type I interface {ok() int}
        type T struct {S int}
        
        func (t T) ok() int { return 666}
        
        func main() {
        	var i I
        	t := T{2}
        	i = t
        	switch v:=i.(type){  //这里将i.(type)的返回值赋给变量v,后面在case或default语句块中可以引用这个变量v. 
        	case T:    //在这里因为case T被匹配上了,所以变量v的类型为T,值为当前接口类型值T{2},即 var v T = T{2}
        		fmt.Println("T")
        		fmt.Println(v)
        	default:
        		fmt.Println("other")
        	}
        }
-----当前接口变量值的类型和所有case后面的类型都不匹配-----
        type I interface {ok() int}
        type T struct {S int}
        type Q struct {S int}
        
        func (t T) ok() int { return 666}
        func (q Q) ok() int { return 666}
        
        func main() {
        	var i I
        	t := Q{2}
        	i = t
        	switch v:=i.(type){  //这里将i.(type)的返回值赋给变量v,后面在case或default语句块中可以引用这个变量v. 在这里因为case T没有被匹配上了,所以变量v的类型和值同i,即, var v Q = Q{2}, 这里要注意了,如果你要说i的类型为I就没啥意义了, 要用i的underylying type和underylying value才有意义.
        	case T:
        		fmt.Println("T")
        		fmt.Println(v)
        	default:
        		fmt.Println("other")
        		fmt.Println("v = %T\n",v)
        		fmt.Println("i = %T\n",i)
        	}
        }
	**.其实上面a,b两点说的是一回事, 因为同一时刻接口i只有一个类型值, 无论case中的类型是否为i当前值的类型,最终v的值和类型都和前面i的相同.
    *.上一节讲"类型推断"时,可以有两个变量, 但该swtich结构中只能有0个或1个变量.
    *.另外,如果想判断某个变量到底是什么类型,可以通过fmt.Printf("var_name = %T\n",var_name)的方法;还可以通过引入reflect包,然后使用fmt.Println("var1 = ", reflect.TypeOf(var1))或fmt.Println("var1 = ",reflect.ValueOf(var1).Kind()).比如type X []int, 有一个变量的类型是X, 则头两种输出的类型是X, 第三种输出的是[]int, 其实比较二三也可看出,三比二多调了一个kind()方法(变量类型输出的方法参考自: https://www.geeksforgeeks.org/different-ways-to-find-the-type-of-variable-in-golang/)
*/

Stringers
1.这节主要讲的是fmt包中定义了一个名为Stringer的接口,type Stringer interface {String() string},而fmt包中所有的打印函数以及某些包的打印功能,其实调的都是Stringer接口中的String()函数. 重点来了, 所以如果我们想要自定义A类型值和B类型值的打印内容,就可以使用A和B分别实现Stringer接口的String()函数,这样我们在使用类似于fmt.Println(A,B)的时候,实际上执行的是A.String(), B.String().下面通过一个例子看一下
    type Person struct { Name string, Age int }
    func (p Person) String() string { return fmt.Sprintf("%v (%v years)", p.Name, p.Age) }   //Person类型实现了fmt包中Stringer接口中的String()方法
    func main() {
        a := Person{"Arthur Dent", 42}}   //得到Person类型变量a
        z := Person{"Zaphod Beeblebrox", 9001}  //得到Person类型变量z
        fmt.Println(a, z)  //该句在实际执行的时候,其实执行的是a.String()和z.String()
*.官文中还讲了实现String()方法以达到自定义输出内容格式,在写go代码时十分常见.
Exercise: Stringers
1. 下一轮统一看Exercise
Errors
1.在go中, 内建类型中有一个叫error的接口,其定义为: type error interface { Error() string },我们平时在函数或方法中返回的错误值,通常就是通过该接口进行格式化输出的.
2.到目前为止接触了两个比较常用的接口,一个是之前讲的fmt包中的Stringer接口,还有一个就是上一条说的内建的error接口,通过实践发现, 在使用fmt包的打印函数时,先找的是Error()函数, 然后才是找String()函数.见例子:
  a.当错误返回值类型为error类型时:
     此时,返回值类型肯定是已经实现了Error()方法了,不然是不可能成功执行的,此时fmt包的输出语句调用的肯定是返回值类型的Error()方法,即使现在同时存在返回值类型的String()方法:

    type V struct {S string}
    func (v *V) String() string {   //*V类型实现了Stringer接口
    	return "String-" + v.S
    }
    func (v *V) Error() string {   //*V类型同样实现了error接口
    	return "Error-" + v.S
    }
    
    func Test(x int) (int, error) {   //这个Test函数的错误返回值类型为error接口类型. 这么写的话, 该函数中return的第2个返回值类型要不是nil,要不是上面已经实现了Error()方法的类型.
        if x > 0{
    	return x, nil
        } else {
    	return 0, &V{"error, not a positive!"}
        }
    }
    
    func main() {
    	fmt.Println(Test(5))   // 5 <nil>   //5大于0,返回的是5和nil,由于nil没有作为任何类型的接收器, 所以原样输出了
    	fmt.Println(Test(-5))   // 0 Error-error, not a positive!  //-5小于0,返回的是V指针,所以最终实际执行的是&V{"error, not a positive!"}.Error()这个方法.这里要说明的是,虽然上面也定义了*V类型的String()方法,但它的优先级没有Error()高(最后一句是猜的,但从实际的测试结果来看,这样解释目前是合理的).
    }

  b.当错误返回值类型为非error类型时:
    <1>.当Stringer接口和error接口都被实现的情况下, Error()方法优先被调用:

    type V struct {S string}
    func (v *V) String() string {   //*V类型实现了Stringer接口
    	return "String-" + v.S
    }
    func (v *V) Error() string {   //*V类型同样实现了error接口
    	return "Error-" + v.S
    }
    
    func Test(x int) (int, *V) {   //注意这里和a中不一样了,a中的返回值类型为error,现在变成了*V
        if x > 0{
    	return x, nil
        } else {
    	return 0, &V{"error, not a positive!"}
        }
    }
    
    func main() {
    	fmt.Println(Test(5))    //输出同a例
    	fmt.Println(Test(-5))   //输出同a例, 虽然返回值类型变了,但是还是以Error()接口优先,所以最终执行的还是&V{"error, not a positive!"}.Error()
    }

    <2>.当只有error接口被实现的情况下, 肯定调的是Error()方法:

    type V struct {S string}
    func (v *V) Error() string {   //*V类型只实现了error接口
    	return "Error-" + v.S
    }
    
    func Test(x int) (int, *V) {   //注意这里和a中不一样了,a中的返回值类型为error,现在变成了*V
        if x > 0{
    	return x, nil
        } else {
    	return 0, &V{"error, not a positive!"}
        }
    }
    
    func main() {
    	fmt.Println(Test(5))    //输出同a例
    	fmt.Println(Test(-5))   //输出同a例, 虽然返回值类型变了,但是此时只有Error()接口,因此这块执行的还是&V{"error, not a positive!"}.Error()
    }

    <3>.当只有Stringer接口被实现的情况下,因为没实现error接口,故一开始找不到Error()方法,所以此时调的是String()方法:

    type V struct {S string}
    func (v *V) String() string {   //*V类型只实现了Stringer接口
    	return "String-" + v.S
    }
    
    func Test(x int) (int, *V) {   //注意这里和a中不一样了,a中的返回值类型为error,现在变成了*V
        if x > 0{
    	return x, nil
        } else {
    	return 0, &V{"error, not a positive!"}
        }
    }
    
    func main() {
    	fmt.Println(Test(5))    //输出同a例
    	fmt.Println(Test(-5))   // 0 String-error, not a positive!这的输出就不一样了,因为只实现了String()方法,没有找到Error()方法,所以最终调的是&V{"error, not a positive!"}.String()
    }

3.再就是最重要的,这个Errors到底用在什么场景下:
  而使用方法其实上面这几个例子已经提到了,只不过在main()函数中不同:
    func main() {
        a,b = Test(5)
        if b == nil {
           fmt.Println(a)
        } else {
          fmt.Println("出错啦")
        }
    }   //也就是说在函数返回后, 会先通过错误返回值判断一下操作是否成功了,成功执行啥操作,不成功执啥操作.
4.还有一点需要注意的: 官文说的对于error接口nil返回值为执行成功,非nil为执行失败,这其实是一个让你在编码的时候遵守的一个约定.你可以不遵守这个约定, 比方说你就是要返回0表示成功,这也是没有问题的, 只不过如上面第3点所写的if判断那块,改为相应的值即可.但你这样写的话,会让其它不了解你代码风格的人产生困惑,这个人必须要看你的代码才能明白. 而nil表示成功,非nil表示失败,是大多数人在编码是遵守的一个约定,你按约定写, 别人一看就明白.
5.另外我发现,别人写的源码,基本上Error()方法的接收器类型都是指针,我想了想,pointer receiver和value receiver的区别说白了就是否在声明类型时被分配的那块内存原位置改; 当Error()中有修改接收器类型fields的语句时,建议使用value receiver,因为后面该类型再调Error()方法时不会受之前调用的影响; 当Error()中只有像fmt.Println()这种输出语句,无修改fields的语句时,建议用pointer receiver,可以减少copy复本的那步,提高性能.
Exercise: Errors
1.下一轮做该练习
Readers
1.小节标题为"Readers"可以理解为读取器
2.io包中，有一个名为Reader的接口，并且在io包中对该Reader接口作了实现: func (T) Read(b []byte) (n int, err error) {}; (官文说Go的标准库中包含了许多对这类接口的实现，说白了就是包含许多相应的方法(methods), 所谓实现不就是实现接口中的方法嘛)。该Read()的理解：它的返回值有2个，一个是进入[]byte中元素的个数(整型)，另一个是错误值(error接口类型)。官文说Read方法是位于带有数据的byte分片中([]byte),然后监控每次进入[]byte的元素个数，返回时将本次进入[]byte中的元素个数以整型返回，并且返回一个类型为error接口类型的错误值，如果没有错误返回nil,如果没有元素进入，则返回的两个值，一个是0，一个是EOF。通过这节带的例子最好理解了:
import ("fmt"; "io"; "strings")
func main() {
    r := strings.NewReader("Hello, Reader!")
    
    b := make([]byte, 8)    //定义一个长度为8个字节的数组b  //应该不是数组，是slice吧?
    for {     //循环读取r中的数据，每次最多8个字节，直到读取完毕
        n, err := r.Read(b) //注意Read()方法的用法
        fmt.Printf("n = %v err = %v b = %v\n", n, err, b)
        fmt.Printf("b[:n] = %q\n", b[:n])
        if err == io.EOF {   //当到达结尾则执行break退出循环
            break
        }
    }
}
执行结果:
n = 8 err = <nil> b = [72 101 108 108 111 44 32 82]
b[:n] = "Hello, R"
n = 6 err = <nil> b = [101 97 100 101 114 33 32 82]
b[:n] = "eader!"
n = 0 err = EOF b = [101 97 100 101 114 33 32 82]
b[:n] = ""
从结果中解读:循环第一次执行，n, err := Read(b)这句执行完成后，b中被读入8个字节，因为没有任何错误，也没有到达字符串的结尾，所以n = 8 err = <nil>，b中的字节为"Hello, R"这8个字符的ascii值；到此第一次循环导致的头两行输出应该没啥疑问; 继续，此时"Hello, Reader!"这个字符串中的字符仅剩下"eader!"这6个字符了；当第二次循环执行完n, err := Read(b)后，字符串剩余的6个字符被读入数组b，从前向后进行覆盖填充，所以你会看到结果输出的字节最后两个是一样的，因为第二次读取只剩下6个字符了，覆盖填充的时候，只能覆盖数组b的头6个字节；到这第三四行的输出应该也没啥疑问的了；继续，此时字符串为空了，第三次执行循环，当n, err := r.Read(b)执行完成后，因为没有字符进入数组b,所以Read()自然监听数组b的进入字符数是0，则n = 0,因为已经到了字符串的结尾，所以err = EOF,此时字节数组b中还是第二个循环中的内容，所以打印出来的ascii值和第二次循环是一样的。
*.感觉有一点需要注意一下，就是第二次明明就将字符串中的字符给读取尽了，但是得到的错误值还是<nil>而不是EOF,所以暂且猜测，一次读取时，只要还能读取到数据，虽然已将字符串读空了，但此时的err返回值依然是<nil>,只有在某一次循环中，从指定对象中一个字符也读不出来的时候，才会返回err为EOF
Exercise: Readers
1.已看, 基线是实现io.Reader接口,该接口只定义了一个方法,Read(b []byte) (n, err).
Exercise: rot13Reader
1.已看, 这节引入了流中流的概念.即将ReaderA传给ReaderB.然后就是rot13是啥意思;以及io.Copy()方法的实现.总的来说这个练习要看新引入的方法代码实现,否则就一个调用代码不知道具体实现过程,总是有点弄不明白.
Images
1.这节我之前认为是一个exercise了,其实不是, 但它只是介绍了go中image包,而不是讲解相应的语法
Exercise: Images
1.已看, 看着没引入新的语法,只是要告诉我们go可以处理图片.
Goroutines
1.轻量级线程
2.通过delve调试来看, main()函数其实也是新建协程执行的. 也就是说main()函数在执行前,被处理成 go main()了,然后执行的时候,先进一个主线程,这个主线程执行main()函数所在的协程.

import (
	"fmt"
	"time"
)

func say(s string) {
	for i := 0; i < 5; i++ {
		time.Sleep(100 * time.Millisecond)
		fmt.Println(s)
	}
}

func main() {   //在这下断
	go say("world-A")
        say("hello")
   //time.Sleep(10000 * time.Millisecond)
}

-----调试信息-----
(dlv) b main.go:20                                                             //断在main()函数
Breakpoint 2 set at 0x4b6b2f for main.main() ./main.go:20
(dlv) c
> main.main() ./main.go:20 (hits goroutine(1):1 total:1) (PC: 0x4b6b2f)
    15:			time.Sleep(100 * time.Millisecond)
    16:			fmt.Println(s)
    17:		}
    18:	}
    19:	
=>  20:	func main() {                            //已经断在这了
    21:		go say("world-A")
    22:		//go say("world-B")
    23:		//go say("world-C")
    24:		//go say("world-D")
    25:		//go say("world-E")
(dlv) threads
* Thread 138200 at 0x4b6b2f ./main.go:20 main.main     //线程138200执行的main.main函数
  Thread 138203 at 0x47045d /root/golang/go/src/runtime/sys_linux_amd64.s:145 runtime.usleep
  Thread 138204 at 0x47045d /root/golang/go/src/runtime/sys_linux_amd64.s:145 runtime.usleep
  Thread 138205 at 0x470ac3 /root/golang/go/src/runtime/sys_linux_amd64.s:580 runtime.futex
  Thread 138206 at 0x470ac3 /root/golang/go/src/runtime/sys_linux_amd64.s:580 runtime.futex
(dlv) goroutines
* Goroutine 1 - User: ./main.go:20 main.main (0x4b6b2f) (thread 138200)    //线程138200执行的协程main.main,通过这句和上句注释表明,main函数也是协程
  Goroutine 2 - User: /root/golang/go/src/runtime/proc.go:337 runtime.gopark (0x43bdd5) [force gc (idle)]
  Goroutine 3 - User: /root/golang/go/src/runtime/proc.go:337 runtime.gopark (0x43bdd5) [GC sweep wait]
  Goroutine 4 - User: /root/golang/go/src/runtime/proc.go:337 runtime.gopark (0x43bdd5) [GC scavenge wait]
  Goroutine 5 - User: /root/golang/go/src/runtime/mfinal.go:161 runtime.runfinq (0x41ad20)
[5 goroutines]


3.新建协程需要两步, 第一步:新建要在新协程中运行的函数. 第二步,在执行函数时,前缀一个关键字go, 如 go say("Hello"),并且要注意新建的协程默认也会新起一个线程去执行的:
    import (
    	"fmt"
    	"time"
    )
    
    func say(s string) {
    	for i := 0; i < 5; i++ {
    		time.Sleep(100 * time.Millisecond)
    		fmt.Println(s)  //在这下断点,因为main()函数中的两条语句调的其实都是这个函数,在这下断,然后看一下线程和协程情况就知道那两个函数运行时起了几个协程几个线程
    	}
    }
    
    func main() {
    	go say("world-A")  //这会新起一个协程
            say("hello") //这句在主协程中运行
       //time.Sleep(10000 * time.Millisecond)
    }
    
    -----调试输出-----
    (dlv) b main.go:16    //断在fmt.Println(s)
    Breakpoint 1 set at 0x4b6a46 for main.say() ./main.go:16
    (dlv) c
    > main.say() ./main.go:16 (hits goroutine(6):1 total:2) (PC: 0x4b6a46)
    > main.say() ./main.go:16 (hits goroutine(1):1 total:2) (PC: 0x4b6a46)
        11:	)
        12:	
        13:	func say(s string) {
        14:		for i := 0; i < 5; i++ {
        15:			time.Sleep(100 * time.Millisecond)
    =>  16:			fmt.Println(s)   //断在这了,注意,断在这说明这句还未执行,下面看看线程和协程数量情况
        17:		}
        18:	}
        19:	
        20:	func main() {
        21:		go say("world-A")
    (dlv) threads
      Thread 137877 at 0x470ac3 /root/golang/go/src/runtime/sys_linux_amd64.s:580 runtime.futex
      Thread 137882 at 0x47045d /root/golang/go/src/runtime/sys_linux_amd64.s:145 runtime.usleep
      Thread 137883 at 0x4b6a46 ./main.go:16 main.say                                               //线程137883
      Thread 137884 at 0x470ac3 /root/golang/go/src/runtime/sys_linux_amd64.s:580 runtime.futex
    * Thread 137885 at 0x4b6a46 ./main.go:16 main.say                                               //线程137885
    (dlv) goroutines
    * Goroutine 1 - User: ./main.go:16 main.say (0x4b6a46) (thread 137885)                                       //由线程137885执行的main.say
      Goroutine 2 - User: /root/golang/go/src/runtime/proc.go:337 runtime.gopark (0x43bdd5) [force gc (idle)]
      Goroutine 3 - User: /root/golang/go/src/runtime/proc.go:337 runtime.gopark (0x43bdd5) [GC sweep wait]
      Goroutine 4 - User: /root/golang/go/src/runtime/proc.go:337 runtime.gopark (0x43bdd5) [GC scavenge wait]
      Goroutine 5 - User: /root/golang/go/src/runtime/proc.go:337 runtime.gopark (0x43bdd5) [finalizer wait]
      Goroutine 6 - User: ./main.go:16 main.say (0x4b6a46) (thread 137883)                                      //由线程137883执行的main.say
    [6 goroutines]

4.上面讲到的是每个协程都由一个新的线程执行.其实这是不完全正确的.默认情况下执行协程的线程数的多少,看的是当前机器的核心数,即 go程序默认启用的线程数的最大值应该等于机器的核心数,如我的机器是四核的,则go默认最多启用4个线程. 即使你有8个go say("x"),也只会由4个线程运行它们, 而具体将哪个协程分配给哪个线程就是内部机制了. 而一个线程运行多个协程时,应该也有一个协程队列:


import (
	"fmt"
	"time"
)

func say(s string) {
	for i := 0; i < 5; i++ {
		time.Sleep(100 * time.Millisecond)
		fmt.Println(s)   //断点下在这
	}
}

func main() {
	go say("world-A")   //总共有8个协程,其中前7个是新建的协程中运行,第8个是在主协程中运行
	go say("world-B")
	go say("world-C")
	go say("world-D")
	go say("world-E")
	go say("world-F")
	go say("world-G")
        say("hello")
   //time.Sleep(10000 * time.Millisecond)
}

-----调试信息-----

(dlv) b main.go:16
Breakpoint 1 set at 0x4b6a46 for main.say() ./main.go:16
(dlv) c
> main.say() ./main.go:16 (hits goroutine(7):1 total:4) (PC: 0x4b6a46)    //只运行了四个协程,7,9,12,11,但从上面代码看共有8个协程
> main.say() ./main.go:16 (hits goroutine(9):1 total:4) (PC: 0x4b6a46)
> main.say() ./main.go:16 (hits goroutine(12):1 total:4) (PC: 0x4b6a46)
> main.say() ./main.go:16 (hits goroutine(11):1 total:4) (PC: 0x4b6a46)
    11:	)
    12:	
    13:	func say(s string) {
    14:		for i := 0; i < 5; i++ {
    15:			time.Sleep(100 * time.Millisecond)
=>  16:			fmt.Println(s)   //断点下在这
    17:		}
    18:	}
    19:	
    20:	func main() {
    21:		go say("world-A")
(dlv) threads
* Thread 138301 at 0x4b6a46 ./main.go:16 main.say     //线程 138301
  Thread 138307 at 0x47045d /root/golang/go/src/runtime/sys_linux_amd64.s:145 runtime.usleep
  Thread 138308 at 0x4b6a46 ./main.go:16 main.say    //线程 13838
  Thread 138309 at 0x4b6a46 ./main.go:16 main.say    //线程 138309
  Thread 138310 at 0x4b6a46 ./main.go:16 main.say    //线程 138310
(dlv) goroutines
  Goroutine 1 - User: /root/golang/go/src/runtime/time.go:193 time.Sleep (0x46bef2)                        //协程1
  Goroutine 2 - User: /root/golang/go/src/runtime/proc.go:337 runtime.gopark (0x43bdd5) [force gc (idle)]
  Goroutine 3 - User: /root/golang/go/src/runtime/proc.go:337 runtime.gopark (0x43bdd5) [GC sweep wait]
  Goroutine 4 - User: /root/golang/go/src/runtime/proc.go:337 runtime.gopark (0x43bdd5) [GC scavenge wait]
  Goroutine 5 - User: /root/golang/go/src/runtime/proc.go:337 runtime.gopark (0x43bdd5) [finalizer wait]
  Goroutine 6 - User: /root/golang/go/src/runtime/time.go:193 time.Sleep (0x46bef2)                       //协程2
  Goroutine 7 - User: ./main.go:16 main.say (0x4b6a46) (thread 138308)                                    //协程3
  Goroutine 8 - User: /root/golang/go/src/runtime/time.go:193 time.Sleep (0x46bef2)                       //协程4
  Goroutine 9 - User: ./main.go:16 main.say (0x4b6a46) (thread 138309)                                    //协程5
  Goroutine 10 - User: /root/golang/go/src/runtime/time.go:193 time.Sleep (0x46bef2)                      //协程6
* Goroutine 11 - User: ./main.go:16 main.say (0x4b6a46) (thread 138301)                                   //协程7
  Goroutine 12 - User: ./main.go:16 main.say (0x4b6a46) (thread 138310)                                   //协程8
[12 goroutines]

5.多个协程运行在同一个地址空间，所以访问数据时注意synchronous问题,基础的是要用到sync包中的函数,这个后面会讲到
6.并发主要用的是runtime包.所以掌握这个包很重要. 刚学的是runtime包里的GOMAXPROCS(n)函数,作用是设置执行协程的线程数.配合delve调试程序的b,c,threads,goroutines来检察设置不同的线程数时,线程和协程的实际情况.需要注意的是,这里面的n,不包含调用系统功能的那些线程.也就是说你在threads里看到的线程数可能要大于你设置的数字n.而怎么看线程执行的是系统调用呢, 我现在的技巧就是从threads中看文件名称带sys前缀的这个线程就是系统调用. 另外1.png讲的是进程,线程,cpu分片的基本概念,网上找的,感觉好理解就截图存下了
7.time.Sleep()是协程线程阻塞的而非线程阻塞的.go中main()函数虽说没有前缀go,但其实也是运行在协程中的.
8.另外,在使用delve时,下断点的位置很重要,可能参考第4点中的那些例子.

Channels
1.通道就像一根管子，可以接收或发送数据
2.通道符号是 "<-"
3.使用make函数得到一个通道类型的变量 ch := make(chan int)
4.发送接收数据的一般形式: a.将数据送入通道: ch <- v;
                          b.从通道读取数据: v:= <-ch;
5.默认情况下，发送和接收数据都是阻塞的，直到另一方准备好,所以可以利用管道的这个特性来实现syncronization:

    var result int = 0
    func sum(c chan int, d chan int) {  //d参数完全是为了判断协程是否都执行结束才加上的, 但看了下面switch中判断结束的语句有点自欺欺人,就是通过result是否为100000来判断的,如果中途出现问题了,没有执行完毕,返回的也是100000,那就不好玩了,有点掩耳盗铃的味道.
    	result = <- c
    	result += 1
    	switch result{
               case 100000: 
                   d <- result
               default: 
                   c <- result
           }
    }
    func main() {
    	ch := make(chan int)
    	ch1 := make(chan int)
    	for i:=0;i<100000;i++{
    		go sum(ch,ch1)
    	}
    	ch <- result  //这句要注意,向ch管道中发送内容一定要放到for语句后面,要不就死锁了,如果放在for语句前,则for语句永远也不会执行,因为这句一直等待有其它协程里的从ch中接收值的语句被执行才会向下走. 通过试验得知,通道不是线程阻塞的,所以将runtime.GOMAXPROCS(n)中的n值设置为1也是没有问题的, 也就是说ch<-result运行在主协程,当这句执行完后,暂时没有发现有变量从管道接收数据,则主线程会转去执行其它协程中的语句(之前认为ch <- result是线程阻塞而不是协程阻塞,也就是说ch<-result执行后,如果是单线程就会一直卡死在这造成死锁,其实不是的,因为所有的函数都是在协程中执行的包括main函数).
    	result = <- ch1  //这句是后来加的,一直不知道怎么优雅的让所有协程都执行完毕,所以又多设置了一个通道ch1,然后给sum()函数多加了个d参数,以及sum()中的switch语句.之前是单纯的在fmt语句前加上time.Sleep(),但这样太傻了.目前这样做也不好,为了判断协程是否都执行完了多执行了好多个switch语句,这样的结果是协程越多性能越低,如果有像kotlin中runBlock{}语句块就好了.
    	fmt.Println(result)
    }   
*.之前认为make(chan int)默认就是make(chan int, 1), 其实不是的, 没有缓冲就是没有缓冲
func main() {
  ch := make(chan int)   //声明一个没有缓冲的整型通道
  ch <- 3  //因为没有缓冲,而又没有其它协程从通道里等着读取,所以这一步就协程阻塞了,直到某个新协程里有类似x := <- ch这样的语句,golang才告诉ch <- 3说,你发吧,那边有人接着了
  fmt.Println("don't display!")  //因为上面一直协程阻塞着,所以这条语句永远不会执行
}
 而
func main() {
  ch := make(chan int,1)  //建立缓冲为1的通道
  ch <- 3  //因为缓冲为1,所以此时3能正常的发到通道里,这句不会阻塞, 无论有没有其它协程正在等着接收, 因为声明的通道中有一个空座, 我能坐下, 逻辑上是通的
  fmt.Println("don't display!")  //最终这句能被执行
}

6.貌似Go中我们不可以自己管理线程, 咋利用多核? //上一小节说了,如果是在多核机器上运行默认用的就是多核,因为GOMAXPROCS默认值就是cpu的逻辑核心数.但默认用多核也不一定好,有些时候单线程要比多线程速度快.
Buffered Channels
1.通道声明时可以设置make第二个参数为通道的buffer: c := make(chan int, 2)
2.一直向通道中发送内容，直接达到通道设置的buffer数
3.从通道接收内容，直接通道中内容为空
4.看一个死锁的例子:   ch := makee(chan int, 1)
                      ch <- 1
                      ch <- 2
                      *.此时1发送到了通道的缓冲区中等待被接收，ch <- 1就执行过了，而此时ch通道缓冲区就1,已经满了,又没有其它协程从通道接收1,所以2就一直等待着发往ch,但因为没有变量接收1，所以就卡死在这了，解决方法是将make中的缓冲参数改为2
*.从4可以看出, buffer channel死锁的情况: 1.缓冲区已经满了, 没语句接收, 此时还向缓冲区发送数据的语句就会阻塞造成死锁; 2.缓冲区已经空了,没语句向里面发了, 但还有语句一直等着从里接收数据,这个语句就会阻塞造成死锁.  //重要的一句, 阻塞的只是语句所在的协程,最主要的就是阻塞在main协程中, 一阻塞程序就deadlock了, 但阻塞在其它协程中程序还是能正常结束的,因为主协程退出了,其它协程也就自动消亡了,但此时被阻塞的协程是否有影响就要看实际的程序逻辑了
*.协程这块要注意几点: 1.语句是线程阻塞吗?是协程阻塞吗? 而在协程中应用通道,则还要注意: 主协程向通道发送内容后,有其它协程接收它吗?等等  
Range and Close
1.range是个关键字,在通道这的用法是i:=range channel; close是个函数,在通道这的用法是close(channel)  //之前讲的range slice可以有两个值
2.在实际使用时,从通道里取值通常是两种方法,使用range关键字,使用<-符号:
  a.使用<-符号时,返回值有两个,一个是返回值,还有一个是布尔值用来检测通道是否关闭:

        func num(c chan int) {
          for i:=0; i<10; i++ {   //使用for循环向通道依次发送0-9共10个数
             c <- i     //将数送往通道,如果没有语句从c中接收就一直等着,如果有语句接收就将下一个i送到通道c中
          }
          close(c)  //当for循环将10个数都送到通道中了,就调用close()函数关闭通道,从通道中接收内容的语句相应的会得到一个false值,知道通道已经被关闭了,不会再有数据再过来了.
        }
        func main() {
        	ch := make(chan int)
        	go num(ch)   //在新建协程并在新协程中执行函数
                for {
        	v,ok:= <- ch  //使用<-符号,每次从通道中接收值时,都可以得到两个值,一个是发送到管道的值,一个是管道当前状态,是一直通的(true),还是已经被关闭了(false).
        		if ok == true{     //通过if...else语句判断通道是否关闭,从而执行不同的逻辑,如果未关,则输出从管道接收的值,如果关闭了,则中止for循环
                   		//fmt.Println(ok)
        	        	fmt.Println(v)
        	        } else{
                   		//fmt.Println(ok)
        			break
        		}
        	}
        }

  b.使用range关键字时,返回值只有一个,即从通道获取的值(这个小b才是这小节的内容):

        这段代码的执行结果和上面a的相同.
        func num(c chan int) {
          for i:=0; i<10; i++ {
             c <- i
          }
          close(c)
        }
        func main() {
        	ch := make(chan int)
        	go num(ch)
        	for v:= range ch {   
        		fmt.Println(v)
        	} //跟上面的那段代码相比,就这个for循环不一样,看着更简单了,我们只需要从通道ch中接收值,并处理值(在这里是直接输出),不需要关心通道的关闭问题(这应该是写错了,应该是不需要关心for循环的退出问题).猜测应该实际执行的代码和a中的差不多, 只不过range函数将对通道状态的检测以及检测到通道关闭后退出循环都封装好了.也就是说:ror v:=range ch {fmt.Println}在执行前会被编译器预处理成: for tmp,v := <- ch { if tmp!=true{break}fmt.Println(v)}
        }
*.总结一下上面两个例子,无论从管道接收数据用的是range形式,还是<-形式,sender一定要用close()函数关闭通道才行(下面马上就会说到sender端不一定要调close(),调它是因为主协程中从通道接收数据的代码位于for循环中, 你不在发送端找时机关闭通道来通知主协程中for里的接收语句,则主协程里的for循环就会一直循环下去,就该例子来说, 还会造成死锁,因为当0-9这10个数发送后num协程就退出了,而主协程中for循环中的语句还在等着收.因为又回到最初的主题了,在发送端调不调close()还要看具体逻辑.但无论怎么看还是调一下好,即使程序执行完这部分内存会被自动回收.);不同的是v,ok <- ch形式需要自己根据ok的值去退出循环,而range形式则不用(具体为啥不用,上一句也有猜测)
*后一我将上面的代码改了一下,向通道发送的还是0-9这10个数字,但是我想发送到第5个就停止发送了,我就在num()函数for循环中又加了个if,结果一开始报错"panic: close of closed channel",看一下到底是怎么回事吧,上代码:

        func num(c chan int) {
          for i:=0; i<10; i++ {
            if i > 5{                
        	    close(c)
        //	    break
            }else{
        	    c <- i
            } //这个if...else是我后加的,当前这个代码就是报上面说的panic,即关闭已经关闭的通道.我们看一下当i=6的时候已经执行close(c)了,但由于此时没有执行break操作,而for循环还未执行完,所以当i=7时,又执行了一次close(c),这次由于c已经在i=6时被关闭了,所以i=7时再执行就报错了.解决方法是将break的注释给去掉,这样在i=6时close(c)的同时将for循环的执行也结束掉了.
        }
        }
        func main() {
        	ch := make(chan int)
        	go num(ch)
                for {
        	v,ok:= <- ch
        		if ok == true{
                   		//fmt.Println(ok)
        	        	fmt.Println(v)
        	        } else{
                   		//fmt.Println(ok)
        			break
        		}
        	}
        }


*.第一小节讲的例子中没有用到close()函数,为啥也没出错呀? 那是因为这节从通道中接收数据是在for循环中,如果发送端没有调用close()函数关闭通道,for循环就会一直执行下去,虽说for i:=range ch表面上没有检测通道关闭状态的变量,但上面也说了猜测相应的逻辑被封装了,实际是有的.我们试一下,主体还是上面的代码,我们将sum()函数中的close()函数去掉,main()函数中的for循环也去掉,就接收一次值:

    func num(c chan int) {
      for i:=0; i<10; i++ {
    	    c <- i
        }
    }   //可以看到num()函数中没有调用close()函数去关闭管道
    func main() {
    	ch := make(chan int)
    	go num(ch)
    	v:= <- ch   //这里只接收了一次值,打印结果是0,没有报错
    	fmt.Println(v)
    }
所以说发送端调不调close()去关闭管道,要看代码的实际逻辑, 通常是像上面代码提到的,接收端如果是在一直等待从管道接收数据,如将接收语句放在for循环中,则即发送端即要有close()的调用,接收端也要有通道状态的检测(或者直接用range).
3.只有sender可以关闭通道，receiver不可以.如果使用receiver关闭了通道,则sender向已关闭的通道中发送数据会发生panic.
4.receiver可以使用"v,ok := <-ch"形式，通过ok的值是true还是false判断通道是否关闭
5.可以使用"for i := range c"的形式来连续的从通道接收值
6.一般不需要sender调用close()函数关闭通道，只有当sender没数据要发了,才需要调用close()函数,将range的第二个返回值由true变为false,当receiver检测到第二个参数值为false时,会做一些其它操作,如关闭for循环. //这点和第2大点重复了,但先不删.
Select
1.select语句块有多个case,多个case同时对每个case中的channel进行监听，哪个先进来则执行哪个case下的语句, 如果线程执行到该协程中时有多个case中的channel都满足条件了则会随机选择一个满足条件的case执行相应的语句(之前认为select也是从上到下循环的检测case,检测到哪个case条件满足了就执行相应的语句,但通过它说如果多个都满足随机选一个执行,就感觉机制应该是某一检查时刻查看所有case下的通道数据情况,如果有1个,则执行相应case下的语句,如果有多个通道都收到数据了,则随机选一个,执行相应case下的语句.如果按之前想的不停的循环switch下的case,则即使多个通道都有内容了,也是当前循环到谁谁执行,并不是随机.话又说回来了,按照这个逻辑好像也有随机的意思) //需要注意的是这里为什么c通道执行完成后不用执行close()函数? ::因为用close()函数关闭通道的情况是,接收端一直处于接收状态,如果不通知接收端通道已关闭没有内容,如果接收端由主协程运行则会造成死锁.而本节的例子,由于有两个通道,虽然当i=10时不再给c通道发送内容了,但会向quit通道发送内容,而且最后程序还正常退出了.还是那句话,用不用close()要看实际情况,具体上面range and close那小节也提到了
2.注意for{select{}}的连用，注意到select有一个case的语句中有return语句，所以猜测这个return语句退出了函数的执行，所以说不会出现通道的读取情况了，因此省略了close()语句   //是因为return的执行导致fibonacci()函数执行完毕,而该函数也是主协程的最后一条语句,因此主协程正常结束,整个程序也就正常结束了,即使不关闭通道也不会发生主协程死锁的情况,因此不用加
3.另外在这节还学到了,接收通道的内容不一定要有变量,如print(<-c), case <-c,这两个语句都是成立的;另外,还可以直接使用匿名函数,如 go func() {}() //注意最后的括号一定要有,前面的表示匿名函数,你只有加上最后的一对(),才叫对匿名函数的调用
Default Selection
0.网上搜的,还可以定义单向通道,用来生成只读或只写的通道, 只读通道: var readOnly <-chan int; 只写通道: var writeOnly chan <- int
1.这个简单，类似于switch中的default,即其它语句都不满足的情况下执行default下的语句，具体执行是每次线程执行到该协程时如果如果其它case都不满足的话都会执行一遍default下的语句  // 大机制上来说，select本就类似于多条件分支语句switch
2.time.Tick()    //这两个都是定时器,都是在指定时间间后隔返回当前时间,区别是看源码后再聊
3.time.After()
4.time.Sleep()
Exercise: Equivalent Binary Trees
sync.Mutex
1.讲的是sync包中的Mutex模块这里面有两个方法Lock和Unlock，用来处理sync问题.而具体的用法是:新建一个结构体,里面有一个特殊的字段类型是sync.Mutex.其它字段自己加.然后调的时候,先实例化这个结构体,最后调的时候将结构体中的变量放在Lock()和Unlock()方法中间,基本就完事了.
3. defer这个在这里其实没啥讲头,它的作用就是在输出结构体中变量值时先拿到锁, 等拿到值之后,最后不要忘了解锁
Exercise: Web Crawler
===================================
Go中常用的包: fmt,os,net
Stringer是fmt包中声明的接口,内定义了方法String()
Error是内建的接口,内定义了方法Error()
使用print,println等打印值时会调用Stringer中的String()方法，当打印时检测到类型为error时，会调用内建接口Error的Error()方法
文档中每个包都有几个例子，学一个包一开始，先从这些例子开始应该是个好方法

*.本次Default Selection里的练习,以及sync.Mutex的练习没看,看不下去.
